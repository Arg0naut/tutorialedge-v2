<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on TutorialEdge.net</title>
    <link>https://tutorialedge.net/tags/golang/index.xml</link>
    <description>Recent content in Golang on TutorialEdge.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://tutorialedge.net/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Reading in Console Input in Golang</title>
      <link>https://tutorialedge.net/post/golang/reading-console-input-golang/</link>
      <pubDate>Sat, 15 Apr 2017 08:48:49 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/golang/reading-console-input-golang/</guid>
      <description>

&lt;p&gt;This is a quick and simple tutorial on how to read in console text input into your Go (GoLang) program. In this tutorial we&#39;ll be creating the basis for a very simple shell that will take in all user input and simply echo it back to the user.&lt;/p&gt;

&lt;h2 id=&#34;reading-in-full-sentences&#34;&gt;Reading in Full Sentences&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll use Go&amp;rsquo;s while loop equivalent of a for loop without any parameters to ensure our program continues on forever. In this example every time text is entered and then enter is pressed, we assign text to equal everything up to and including the &lt;code&gt;\n&lt;/code&gt; special character. If we want to do comparison on the string that has just been entered then we can use the strings.Replace method in order to remove this trailing &lt;code&gt;\n&lt;/code&gt; character with nothing and then do the comparison.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you want this to work on Windows Systems then you will have to do &lt;code&gt;text = strings.Replace(text, &amp;quot;\r\n&amp;quot;, &amp;quot;&amp;quot;, -1)&lt;/code&gt; as windows uses a different line ending compared to unix systems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;bufio&amp;quot;
  &amp;quot;fmt&amp;quot;
  &amp;quot;os&amp;quot;
  &amp;quot;strings&amp;quot;
)

func main() {

  reader := bufio.NewReader(os.Stdin)
  fmt.Println(&amp;quot;Simple Shell&amp;quot;)
  fmt.Println(&amp;quot;---------------------&amp;quot;)

  for {
    fmt.Print(&amp;quot;-&amp;gt; &amp;quot;)
    text, _ := reader.ReadString(&#39;\n&#39;)
    // convert CRLF to LF
    text = strings.Replace(text, &amp;quot;\n&amp;quot;, &amp;quot;&amp;quot;, -1)

    if strings.Compare(&amp;quot;hi&amp;quot;, text) == 0 {
      fmt.Println(&amp;quot;hello, Yourself&amp;quot;)
    }

  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll see in this example that whenever we enter the word &amp;ldquo;hi&amp;rdquo;, our strings.Compare method will then return a 0 and it will print out hello back.&lt;/p&gt;

&lt;h2 id=&#34;reading-single-utf-8-encoded-unicode-characters&#34;&gt;Reading Single UTF-8 Encoded Unicode Characters&lt;/h2&gt;

&lt;p&gt;If you want to simply read one unicode character from the command line then I recommend you use bufio.ReadRune like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;reader := bufio.NewReader(os.Stdin)
char, _, err := reader.ReadRune()

if err != nil {
  fmt.Println(err)
}

// print out the unicode value i.e. A -&amp;gt; 65, a -&amp;gt; 97
fmt.Println(char)

switch char {
case &#39;A&#39;:
  fmt.Println(&amp;quot;A Key Pressed&amp;quot;)
  break
case &#39;a&#39;:
  fmt.Println(&amp;quot;a Key Pressed&amp;quot;)
  break
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;using-bufio-s-scanner&#34;&gt;Using Bufio&amp;rsquo;s Scanner&lt;/h2&gt;

&lt;p&gt;A third way you could potentially read in input from the console in go is by creating a new scanner and passing os.Stdin just as we have done above creating new readers and then using scanner.Scan in order to read in from the console:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func scanner() {
  scanner := bufio.NewScanner(os.Stdin)
  for scanner.Scan() {
    fmt.Println(scanner.Text())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code will infinitely ask scan for input and echo back whatever is entered.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As you can see there are numerous ways to do this and the best solution depends on your particular needs. If you are only needing single character input then use ReadRune() or if you are wanting to read in full new line delimited sentences then ReadString is the way to go.&lt;/p&gt;

&lt;p&gt;I hope you found this tutorial useful and if you have any further questions then please let me know in the comments section below!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you enjoyed this post then you may like this one on &lt;a href=&#34;https://tutorialedge.net/executing-system-commands-with-golang&#34;&gt;Calling System Commands in Go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Executing System Commands With Golang</title>
      <link>https://tutorialedge.net/post/golang/executing-system-commands-with-golang/</link>
      <pubDate>Sat, 15 Apr 2017 08:47:48 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/golang/executing-system-commands-with-golang/</guid>
      <description>

&lt;p&gt;This tutorial is just a quick and simple tutorial as to how to execute system commands using Google&amp;rsquo;s GoLang programming language.&lt;/p&gt;

&lt;h2 id=&#34;official-documentation&#34;&gt;Official Documentation&lt;/h2&gt;

&lt;p&gt;The official documentation for executing system commands can be found under the exec package: &lt;a href=&#34;https://golang.org/pkg/os/exec/&#34;&gt;Exec Package&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;cross-compatibility-issues&#34;&gt;Cross Compatibility Issues&lt;/h2&gt;

&lt;p&gt;Please note that some of these commands may not work on your operating system. If you are trying to write code that is compatible on multiple platforms then it would be wise to select commands that only feature on all platforms. If this is unachievable then I recommend you add conditional logic to your program that executes a different system command depending on the system it&amp;rsquo;s executing on top of.&lt;/p&gt;

&lt;h4 id=&#34;checking-current-operating-system&#34;&gt;Checking Current Operating System&lt;/h4&gt;

&lt;p&gt;In order to check what operating system our code is running on we can use the runtime package and check the GOOS constant. This will return the operating system target:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    if runtime.GOOS == &amp;quot;windows&amp;quot; {
		fmt.Println(&amp;quot;Can&#39;t Execute this on a windows machine&amp;quot;)
	} else {
		execute()
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full list of GOOS variables can be found here: &lt;a href=&#34;https://golang.org/pkg/runtime/internal/sys/#GOOS&#34;&gt;Sys Package&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;Below is the absolute bare essentials as to how to execute a system command, I&amp;rsquo;ve stripped out all the error handling just to keep it simple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os/exec&amp;quot;
	&amp;quot;runtime&amp;quot;
)

func execute() {

  // here we perform the pwd command.
  // we can store the output of this in our out variable 
  // and catch any errors in err
	out, err := exec.Command(&amp;quot;pwd&amp;quot;).Output()

  // if there is an error with our execution
  // handle it here
	if err != nil {
		fmt.Printf(&amp;quot;%s&amp;quot;, err)
	}

	fmt.Println(&amp;quot;Command Successfully Executed&amp;quot;)
  // as the out variable defined above is of type []byte we need to convert
  // this to a string or else we will see garbage printed out in our console
  // this is how we convert it to a string
	output := string(out[:])

  // once we have converted it to a string we can then output it.
	fmt.Println(output)
}

func main() {

	fmt.Println(&amp;quot;Simple Shell&amp;quot;)
	fmt.Println(&amp;quot;---------------------&amp;quot;)

	if runtime.GOOS == &amp;quot;windows&amp;quot; {
		fmt.Println(&amp;quot;Can&#39;t Execute this on a windows machine&amp;quot;)
	} else {
		execute()
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;exit-codes&#34;&gt;Exit Codes&lt;/h2&gt;

&lt;p&gt;// to be added&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you found this tutorial useful or wish to ask anything extra then please feel free to do so in the comments section below!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating A Simple Web Server With Golang</title>
      <link>https://tutorialedge.net/post/golang/creating-simple-web-server-with-golang/</link>
      <pubDate>Sat, 15 Apr 2017 08:46:33 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/golang/creating-simple-web-server-with-golang/</guid>
      <description>

&lt;p&gt;In this tutorial we&amp;rsquo;ll be focusing on creating a very simple web server using the &lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;net/http&lt;/a&gt; package. If you&amp;rsquo;ve ever used something like Node&amp;rsquo;s ExpressJS or Python&amp;rsquo;s Tornado, then you should hopefully see some similarities to how things are handled.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-basic-web-server&#34;&gt;Creating a Basic Web Server&lt;/h2&gt;

&lt;p&gt;Ok, so to begin with we’ll create a very simple web server that will just return whatever the URL path is of your query. This will be a good base from which we can build on top of.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;html&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
)

func main() {

    http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, &amp;quot;Hello, %q&amp;quot;, html.EscapeString(r.URL.Path))
    })
    
    http.HandleFunc(&amp;quot;/hi&amp;quot;, func(w http.ResponseWriter, r *http.Request){
        fmt.Fprintf(w, &amp;quot;Hi&amp;quot;)
    })

    log.Fatal(http.ListenAndServe(&amp;quot;:8081&amp;quot;, nil))

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above code we essentially define two different Handlers. These handlers are what respond to any http request that match the string pattern we define as the first parameter. So essentially whenever a request is made for the home page or &lt;em&gt;&lt;a href=&#34;http://localhost:8081/&#34;&gt;http://localhost:8081/&lt;/a&gt;&lt;/em&gt;, we&amp;rsquo;ll see our first handler respond as the query matches that pattern.&lt;/p&gt;

&lt;h2 id=&#34;running-our-server&#34;&gt;Running Our Server&lt;/h2&gt;

&lt;p&gt;Ok so now that we&amp;rsquo;ve created our own very simplistic server we can try running it by typing go run server.go into our console. This usually asks me for permission so accept that and then head over to your browser and head to &lt;a href=&#34;http://localhost:8081/world&#34;&gt;http://localhost:8081/world&lt;/a&gt;. On this page you should hopefully see your query string echoed back to you in true &amp;ldquo;hello world&amp;rdquo; fashion.&lt;/p&gt;

&lt;h2 id=&#34;adding-a-bit-of-complexity&#34;&gt;Adding a bit of Complexity&lt;/h2&gt;

&lt;p&gt;So now that we&amp;rsquo;ve got a basic web server set up, let&amp;rsquo;s try incrementing a counter every time a specific url is hit. Due to the fact that the web server is asynchronous, we&amp;rsquo;ll have to guard our counter using a mutex in order to prevent us from being hit with race-condition bugs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;sync&amp;quot;
)

var counter int
var mutex = &amp;amp;sync.Mutex{}

func echoString(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &amp;quot;hello&amp;quot;)
}

func incrementCounter(w http.ResponseWriter, r *http.Request) {
	mutex.Lock()
	counter++
	fmt.Fprintf(w, strconv.Itoa(counter))
	mutex.Unlock()
}

func main() {
	http.HandleFunc(&amp;quot;/&amp;quot;, echoString)

	http.HandleFunc(&amp;quot;/increment&amp;quot;, incrementCounter)

	http.HandleFunc(&amp;quot;/hi&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, &amp;quot;Hi&amp;quot;)
	})

	log.Fatal(http.ListenAndServe(&amp;quot;:8081&amp;quot;, nil))

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run this and then navigate to &lt;a href=&#34;http://localhost:8081/increment&#34;&gt;http://localhost:8081/increment&lt;/a&gt; and you should see the current count which will be locked, incremented and then unlocked every time you make a request to that page.&lt;/p&gt;

&lt;h2 id=&#34;serving-static-files&#34;&gt;Serving Static Files&lt;/h2&gt;

&lt;p&gt;Ok, so now that we&amp;rsquo;ve set up a simple server in go, it&amp;rsquo;s time to start serving some static files. Create a static folder within your project&amp;rsquo;s directory and then create some simple html files. For this example I&amp;rsquo;m just serving back the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;Hello World&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;h2&amp;gt;Hello World!&amp;lt;/h2&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you&amp;rsquo;ve got this then we can then modify our web server code to use the http.ServeFile method. Essentially this will take in the url of the request made to the server, and if it contains say index.html then it would return the index.html file, rendered as html in the browser. If we were to create an edit.html page and send a request to &lt;a href=&#34;http://localhost:8081/edit.html&#34;&gt;http://localhost:8081/edit.html&lt;/a&gt; then it would return whatever html content you choose to put in that edit.html page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func main() {

	http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, r.URL.Path[1:])
	})

	http.HandleFunc(&amp;quot;/hi&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, &amp;quot;Hi&amp;quot;)
	})

	log.Fatal(http.ListenAndServe(&amp;quot;:8081&amp;quot;, nil))

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;checking-it-works&#34;&gt;Checking it Works&lt;/h2&gt;

&lt;p&gt;Again run the server and navigate to &lt;a href=&#34;http://localhost:8081/index.html&#34;&gt;http://localhost:8081/index.html&lt;/a&gt; and you should hopefully see your very simple index.html file rendered in all it&amp;rsquo;s glory.&lt;/p&gt;

&lt;p&gt;I hope you found this tutorial useful and if you did then please let me know in the comments section below! This is part one of a series of GoLang tutorials in which we play around with APIs and creating servers so stay tuned for more!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Recommended Reading: If you wanted to say display a blog then connecting to a database is vital: &lt;a href=&#34;https://tutorialedge.net/go-mysql-tutorials&#34;&gt;Go MySQL Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Creating a RESTful API With Golang</title>
      <link>https://tutorialedge.net/post/golang/creating-restful-api-with-golang/</link>
      <pubDate>Sat, 15 Apr 2017 08:45:15 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/golang/creating-restful-api-with-golang/</guid>
      <description>

&lt;h2&gt;REST Architectures&lt;/h2&gt;

&lt;p&gt;REST is everywhere these days, from web sites to enterprise applications, the RESTful architecture style is a powerful way of providing communication between various moving by separate software components. Building REST APIs allow you to easily decouple both consumers and producers and are typically stateless by design. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you wish to learn more about the basics of REST APIs then check out &lt;a href=&#34;https://tutorialedge.net/what-are-restful-apis&#34;&gt;What Are RESTful APIs?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;JSON&lt;/h4&gt;

&lt;p&gt;For the purpose of this tutorial we’ll be using JavaScript Object Notation as a means of sending and receiving all information and thankfully Go comes with some excellent support for encoding and decoding these formats using the standard library package, encoding/json. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For more information on the encoding/json package check out the official documentation: &lt;a href=&#34;https://golang.org/pkg/encoding/json/&#34; target=&#34;_blank&#34;&gt;encoding/json&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;Marshalling&lt;/h4&gt;

&lt;p&gt;In order for us to easily We can easily convert data structures in GO into JSON by using something called marshalling which produces a byte slice containing a very long string with no extraneous white space. &lt;/p&gt;

&lt;h2&gt;A Basic Web Server&lt;/h2&gt;

&lt;p&gt;In order for a consumer to consume our API we’ll need to set up some form of server which will constantly listen on our local machine for now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you want a more in-depth tutorial on how to create a go based web server then check out this tutorial here: &lt;a href=&#34;http://tutorialedge.net/creating-a-simple-web-server-with-go-golang&#34;&gt;Creating a Simple Web Server with Go(Lang)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
)

func homePage(w http.ResponseWriter, r *http.Request){
    fmt.Fprintf(w, &amp;quot;Welcome to the HomePage!&amp;quot;)
    fmt.Println(&amp;quot;Endpoint Hit: homePage&amp;quot;)
}

func returnArticle(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &amp;quot;returns a specific article&amp;quot;)
    fmt.Println(&amp;quot;Endpoint Hit: returnArticle&amp;quot;)
}

func returnAllArticles(w http.ResponseWriter, r *http.Request){
    fmt.Fprintf(w, &amp;quot;All Articles&amp;quot;)
    fmt.Println(&amp;quot;Endpoint Hit: returnAllArticles&amp;quot;)
}

func addArticle(w http.ResponseWriter, r *http.Request){
    fmt.Fprintf(w, &amp;quot;Adds an article to list of articles&amp;quot;)
    fmt.Println(&amp;quot;Endpoint Hit: addArticle&amp;quot;)
}

func delArticle(w http.ResponseWriter, r *http.Request){
    fmt.Fprintf(w, &amp;quot;deletes a specific article&amp;quot;)
    fmt.Println(&amp;quot;Endpoint Hit: delArticle&amp;quot;)
}

func handleRequests() {
    http.HandleFunc(&amp;quot;/&amp;quot;, homePage)
    http.HandleFunc(&amp;quot;/all&amp;quot;, returnAllArticles)
    http.HandleFunc(&amp;quot;/single&amp;quot;, returnArticle)
    http.HandleFunc(&amp;quot;/delete&amp;quot;, delArticle)
    http.HandleFunc(&amp;quot;/add&amp;quot;, addArticle)
    log.Fatal(http.ListenAndServe(&amp;quot;:8081&amp;quot;, nil))
}

func main() {
    handleRequests()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Our Articles Structure&lt;/h2&gt;

&lt;p&gt;Once we’ve set up all the endpoints to our API, we can proceed to create a basic model that will store our articles for us and enable us to then encode this into a JSON format and return it via an endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Article struct {
    Title string `json:&amp;quot;Title&amp;quot;`
    Desc string `json:&amp;quot;desc&amp;quot;`
    Content string `json:&amp;quot;content&amp;quot;`
}

type Articles []Article 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Retrieving All Articles&lt;/h2&gt;

&lt;p&gt;We’ve now got everything we need in order to start mocking up some data and returning it. Add &lt;b&gt;“encoding/json”&lt;/b&gt; to your list of imports at the top of the file and then navigate to the &lt;b&gt;returnAllArticles&lt;/b&gt; function and then add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func returnAllArticles(w http.ResponseWriter, r *http.Request){
    articles := Articles{
        Article{Title: &amp;quot;Hello&amp;quot;, Desc: &amp;quot;Article Description&amp;quot;, Content: &amp;quot;Article Content&amp;quot;},
        Article{Title: &amp;quot;Hello 2&amp;quot;, Desc: &amp;quot;Article Description&amp;quot;, Content: &amp;quot;Article Content&amp;quot;},
    }    
    fmt.Println(&amp;quot;Endpoint Hit: returnAllArticles&amp;quot;)
    
    json.NewEncoder(w).Encode(articles)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run this and then open up http://localhost:8081/all in your browser and you should see a json representation of your list of articles like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[{&amp;quot;Title&amp;quot;:&amp;quot;Hello&amp;quot;,&amp;quot;desc&amp;quot;:&amp;quot;Article Description&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Article Content&amp;quot;},{&amp;quot;Title&amp;quot;:&amp;quot;Hello 2&amp;quot;,&amp;quot;desc&amp;quot;:&amp;quot;Article Description&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Article Content&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Getting Started with Routers&lt;/h2&gt;

&lt;p&gt;Now the standard library is adequate at providing everything you need to get your own simple REST api up and running but now that we’ve got the basic concepts down I feel it’s time to introduce third-party router packages. The most notable and highly used is the &lt;a href=&#34;https://github.com/gorilla/mux&#34; target=&#34;_blank&#34;&gt;gorilla/mux router&lt;/a&gt; which, as it stands currently has 2,281 stars on github.&lt;/p&gt;

&lt;h5&gt;Building our Router&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;github.com/gorilla/mux&amp;quot;
)

… // Existing code from above
func handleRequests() {
    
    myRouter := mux.NewRouter().StrictSlash(true)
    myRouter.HandleFunc(&amp;quot;/&amp;quot;, homePage)
    myRouter.HandleFunc(&amp;quot;/all&amp;quot;, returnAllArticles)
    log.Fatal(http.ListenAndServe(&amp;quot;:10000&amp;quot;, myRouter))
}

func main() {
    fmt.Println(&amp;quot;Rest API v2.0 - Mux Routers&amp;quot;)
    handleRequests()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Path Variables&lt;/h5&gt;

&lt;p&gt;So far so good, we’ve created a very simple REST API that returns a homepage and all our Articles. But what happens if we want to just view one article? Well thanks to the gorilla mux router this is easy, we can add variables to our paths and then pick and choose what articles we want to return based of these variables.&lt;/p&gt;

&lt;p&gt;Create a new route in your handleRequest function: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;myRouter.HandleFunc(&amp;quot;/article/{key}&amp;quot;, returnOneArticle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then create the new returnOneArticle function above it like so: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func returnOneArticle(w http.ResponseWriter, r *http.Request){
    vars := mux.Vars(r)
    key := vars[&amp;quot;key&amp;quot;]
    
    fmt.Fprintf(w, &amp;quot;Key: &amp;quot; + key)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So to explain this, in our route we’ve created a key variable. We are then accessing this new key variable within our new function by creating a map called vars and then selecting the key value from this map. We are able to do this for however many variables we want to set in our path like so: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func returnOneArticle(w http.ResponseWriter, r *http.Request){
    vars := mux.Vars(r)
    key := vars[&amp;quot;key&amp;quot;]
    var1 := vars[&amp;quot;var1&amp;quot;]
    var2 := vars[&amp;quot;var2&amp;quot;]
    
    fmt.Println(&amp;quot;Var 1: &amp;quot; + var1)
    fmt.Println(&amp;quot;Var 2: &amp;quot; + var2)
    fmt.Fprintf(w, &amp;quot;Key: &amp;quot; + key)
}

func handleRequests() {
    
    myRouter := mux.NewRouter().StrictSlash(true)
    myRouter.HandleFunc(&amp;quot;/&amp;quot;, homePage)
    myRouter.HandleFunc(&amp;quot;/all&amp;quot;, returnAllArticles)
    myRouter.HandleFunc(&amp;quot;/article/{key}/{var1}/{var2}/&amp;quot;, returnOneArticle)
    log.Fatal(http.ListenAndServe(&amp;quot;:10000&amp;quot;, myRouter))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you run this and hit: http://localhost:10000/article/1/1/2/ you should see your 2 variables printing out in the console and the page should also return Key: 1.&lt;/p&gt;

&lt;h2 id=&#34;real-life-examples&#34;&gt;Real Life Examples&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;If you want a real life RESTful json api to have a look at, why not take a look at the rest api powering this site&amp;rsquo;s backend: &lt;a href=&#34;https://github.com/elliotforbes/tutorialedge-rest-api&#34;&gt;Tutorialedge-Rest-API&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Sending Email Using Go And Mailgun</title>
      <link>https://tutorialedge.net/post/golang/sending-email-using-go-and-mailgun/</link>
      <pubDate>Sat, 15 Apr 2017 08:44:00 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/golang/sending-email-using-go-and-mailgun/</guid>
      <description>&lt;p&gt;In this tutorial I&#39;m going to be demonstrating how you can send mail with Go(Lang) and the mailgun api. Thankfully, mailgun&#39;s API is fantastic and sending mail is incredibly easy once you&#39;ve set everything up properly.&lt;/p&gt;

&lt;h2&gt;Requirements&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;You&#39;ll need a mailgun account with your own verified domains&lt;/li&gt;
&lt;li&gt;Mailgun&#39;s Go Package: Downloadable from here &gt; &lt;a href=&#34;https://github.com/mailgun/mailgun-go&#34; target=&#34;_blank&#34; &gt;https://github.com/mailgun/mailgun-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Your Mailgun&#39;s Public API Key&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Implementation&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;github.com/mailgun/mailgun-go&amp;quot;
)

func SendSimpleMessage(domain, apiKey string) (string, error) {
  mg := mailgun.NewMailgun(&amp;quot;tutorialedge.net&amp;quot;, apiKey, &amp;quot;key-12345671234567&amp;quot;)
  m := mg.NewMessage(
    &amp;quot;Excited User &amp;lt;elliot@tutorialedge.net&amp;gt;&amp;quot;,
    &amp;quot;Hello&amp;quot;,
    &amp;quot;Testing some Mailgun!&amp;quot;,
    &amp;quot;elliot@tutorialedge.net&amp;quot;,
  )
  _, id, err := mg.Send(m)
  return id, err
}

func main(){
    SendSimpleMessage(&amp;quot;postmaster@elliotforbes.co.uk&amp;quot;, &amp;quot;key-12345671234567&amp;quot;)
        
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Writing A Twitter Bot in Golang</title>
      <link>https://tutorialedge.net/post/golang/writing-a-twitter-bot-golang/</link>
      <pubDate>Sun, 09 Apr 2017 21:33:19 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/golang/writing-a-twitter-bot-golang/</guid>
      <description>&lt;p&gt;In this tutorial I’m going to be demonstrating how to build a twitter bot using &lt;a href=&#34;https://github.com/dghubble/go-twitter&#34;&gt;go-twitter&lt;/a&gt;, a popular Go client library for the Twitter API.&lt;/p&gt;

&lt;p&gt;I’ll be demonstrating how you can build a go based twitter bot that will be able to do such things as automatically reply to tweets and favourite tweets that contain a specific hashtag.&lt;/p&gt;

&lt;h2&gt;Connecting to Twitter&lt;/h2&gt;

&lt;p&gt;Just like with the &lt;a href=&#34;https://tutorialedge.net/creating-python-twitter-bot-using-twitter-api&#34;&gt;Python version of this tutorial&lt;/a&gt;, you’ll have to create an app in twitter’s &lt;a href=”https://apps.twitter.com/”&gt;app control panel&lt;/a&gt;. Once you’ve created a new application, it should present you with all the secret tokens and keys that you need in order to proceed.&lt;/p&gt;

&lt;h2&gt;Writing our Basic Go Twitter Bot&lt;/h2&gt;

&lt;p&gt;Once you’ve got all the access tokens and secret tokens ready, it’s time to start implementing our Bot. Create a new file called &lt;b&gt;twitter-bot.go&lt;/b&gt; and add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;os/signal&amp;quot;
    &amp;quot;syscall&amp;quot;
    
    &amp;quot;github.com/dghubble/go-twitter/twitter&amp;quot;
    &amp;quot;github.com/dghubble/oauth1&amp;quot;
)

func configure() {
    // Pass in your consumer key (API Key) and your Consumer Secret (API Secret) 
    config := oauth1.NewConfig(&amp;quot;consumer-key&amp;quot;, &amp;quot;consumer-secret&amp;quot;)
    // Pass in your Access Token and your Access Token Secret
    token := oauth1.NewToken(&amp;quot;access-token&amp;quot;, &amp;quot;access-token-secret&amp;quot;)
    httpClient := config.Client(oauth1.NoContext, token)
    client := twitter.NewClient(httpClient)
    
    
    demux := twitter.NewSwitchDemux()
    
    demux.Tweet = func(tweet *twitter.Tweet){
        fmt.Println(tweet.Text)
    }
    
    demux.DM = func(dm *twitter.DirectMessage){
        fmt.Println(dm.SenderID)
    }
    
    fmt.Println(&amp;quot;Starting Stream...&amp;quot;)
    
    // FILTER
	filterParams := &amp;amp;twitter.StreamFilterParams{
		Track:         []string{&amp;quot;cat&amp;quot;},
		StallWarnings: twitter.Bool(true),
	}
	stream, err := client.Streams.Filter(filterParams)
	if err != nil {
		log.Fatal(err)
	}
    
    // Receive messages until stopped or stream quits
	go demux.HandleChan(stream.Messages)

	// Wait for SIGINT and SIGTERM (HIT CTRL-C)
	ch := make(chan os.Signal)
	signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
	log.Println(&amp;lt;-ch)

	fmt.Println(&amp;quot;Stopping Stream...&amp;quot;)
	stream.Stop()
    
}

func main() {
    fmt.Println(&amp;quot;Go-Twitter Bot v0.01&amp;quot;)
    configure()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>