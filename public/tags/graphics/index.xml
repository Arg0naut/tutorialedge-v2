<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graphics on TutorialEdge.net</title>
    <link>https://tutorialedge.net/tags/graphics/index.xml</link>
    <description>Recent content in Graphics on TutorialEdge.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://tutorialedge.net/tags/graphics/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LWJGL 3 Orthographic Camera Tutorial</title>
      <link>https://tutorialedge.net/post/java/lwjgl3/lwjgl-3-orthographic-camera-tutorial/</link>
      <pubDate>Sat, 15 Apr 2017 09:39:43 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/java/lwjgl3/lwjgl-3-orthographic-camera-tutorial/</guid>
      <description>&lt;p&gt;This tutorial leads on from some of the topics covered in my previous tutorial : How Matrices are used in Game Development so if you haven’t got a good grounding in matrices then I suggest you check that out first. There are several YouTube videos out there that expertly cover the topic of matrices as well so check them out!&lt;/p&gt;

&lt;h2&gt;Orthographic Projection Camera&lt;/h2&gt;

&lt;p&gt;Orthographic cameras are a means of representing 3D points in our game world on a 2D monitor/screen. This basically means that you see objects moving away from the camera getting smaller and thus this is perfect for our 2D games. One of the key things you have to understand from the beginning is that there is no ‘physical’ camera object, the camera is basically represented by a matrix that we can translate, rotate or scale depending on however we need to move the camera.&lt;/p&gt;

&lt;p&gt;In this tutorial we will be building the basic Orthographic projection matrix that is primarily used in 2D games. This orthographic matrix is one of the simplest camera matrices and doesn’t show any form of perspective to our objects in our scenes. Without any form of perspective we will never see objects getting smaller as they go further into the distance, but seeing as 2D games are only represented in terms of X and Y coordinates we don’t tend to worry about perspective in our scenes.&lt;/p&gt;

&lt;p&gt;To create an orthographic matrix we will need 6 float variables:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;left&lt;/li&gt;
&lt;li&gt;right&lt;/li&gt;
&lt;li&gt;bottom&lt;/li&gt;
&lt;li&gt;top&lt;/li&gt;
&lt;li&gt;near&lt;/li&gt;
&lt;li&gt;far&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These will represent the positions of the clipping planes.&lt;/p&gt;

&lt;h2&gt;Representing our Matrix in Code:&lt;/h2&gt;

&lt;p&gt;I wont go into the specifics of how these matrices work as I’m pretty sure there are a hundred different YouTube videos that go to great lengths to describe these things, but I will go onto say that all of this code follows Column-major order just to avoid confusion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Gives us our orthographic matrix
  public static Matrix4f orthographic(float left, float right, float bottom, float top, float near, float far){
  Matrix4f matrix = new Matrix4f();

  matrix.elements[0 + 0 * 4] = 2.0f / (right - left);
  matrix.elements[1 + 1 * 4] = 2.0f / (top - bottom);
  matrix.elements[2 + 2 * 4] = 2.0f / (near - far);

  matrix.elements[0 + 3 * 4] = (left + right) / (left - right);
  matrix.elements[1 + 3 * 4] = (bottom + top) / (bottom - top);
  matrix.elements[2 + 3 * 4] = (far + near) / (far - near);

  matrix.elements[3 + 3 * 4] = 1.0f;

  return matrix;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By doing this we can now create a projection matrix in our initialization using this new method. In the demonstration code this is done like so in our main class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Matrix4f pr_matrix = Matrix4f.orthographic(-10.0f, 10.0f, -10.0f * 9.0f / 16.0f, 10.0f * 9.0f / 16.0f, -10.0f, 10.0f);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Creating Camera Controls&lt;/h2&gt;

&lt;p&gt;So now that we’ve got a matrix that will represent our projection matrix, we will also need some way of tracking and updating where our camera is in the world. We can do this by adding a Vector3f to our Camera class and calling it ‘position’. This will essentially store the coordinates of our camera and allow us to move the camera using the following update method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void update(){		
  if(Input.isKeyDown(GLFW_KEY_W)){
    position.y += 0.05f;
  }
  if(Input.isKeyDown(GLFW_KEY_S)){
    position.y -= 0.05f;
  }
  if(Input.isKeyDown(GLFW_KEY_D)){
    position.x += 0.05f;
  }
  if(Input.isKeyDown(GLFW_KEY_A)){
    position.x -= 0.05f;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Updating Every Model in our Game&lt;/h2&gt;

&lt;p&gt;The way that the game engine has been implemented is that every object currently uses the one shader which looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#version 330 core

layout ( location = 0 ) in vec4 position;
layout ( location = 1 ) in vec2 tc;

uniform mat4 pr_matrix;
uniform mat4 vw_matrix;
uniform mat4 ml_matrix = mat4(1.0);

out DATA
{
	vec2 tc;
} vs_out;

void main()
{
	gl_Position = pr_matrix * vw_matrix * ml_matrix * position;
	vs_out.tc = tc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By adding in the uniform mat4 variable vw_matrix, we can then pass our camera’s view matrix into our shader and multiply the gl_Position variable by the view matrix and update our camera.&lt;/p&gt;

&lt;p&gt;In order for us to pass in our view matrix to our shader we have added the following line to our Main class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Shader.shader1.setUniformMat4f(&amp;quot;vw_matrix&amp;quot;, Matrix4f.translate(camera.position));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;So that should be all you need to get yourself up and running with the demonstration code and your own orthographic projection matrix! If you feel you need more detail on the subject then please leave a comment in the comments section below and I’ll try my best to expand upon the explanations already given!&lt;/p&gt;

&lt;p&gt;You can find the repository for the example code here: &lt;a href=&#34;https://github.com/emforce/AlgebraTutorial&#34;&gt;Github Repo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started With Shaders in OpenGL</title>
      <link>https://tutorialedge.net/post/gamedev/opengl/getting-started-with-shaders/</link>
      <pubDate>Sat, 15 Apr 2017 08:50:41 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/gamedev/opengl/getting-started-with-shaders/</guid>
      <description>&lt;p&gt;The modern OpenGL rendering pipeline rely heavily on shaders to process the huge amounts of data that a highly demanding program like a game requires. These shaders are typically written using the OpenGL Shading Language - GLSL, this language is very similar to C in syntax. &lt;/p&gt;

&lt;p&gt;Learning shaders is just about one of the most important things you can do if you are going to get into graphical programming as it enables you to control just about everything when it comes to rendering your models in a game. Each stage grants an extra level of granularity through which you can create a game that looks like no other and whilst graphics don&#39;t make the game, having an aesthetically pleasing game can certainly help it. &lt;/p&gt;

&lt;h2&gt;The 5 Stages of the Graphical Pipeline&lt;/h2&gt;

&lt;p&gt;The new rendering pipeline was introduced in version 3.1 of OpenGL and whilst I&#39;ve not necessarily had the pleasure of using the old fixed-function pipeline in my development life, I have been told that the newer method is huge improvement. This programmable pipeline contains 4 main stages and one final compute stage and we can control each of these simply by providing a shader.&lt;/p&gt;

&lt;h3&gt;1. Vertex Shading Stage&lt;/h3&gt;

&lt;p&gt;At this stage of the pipeline we receive the vertex data that we&#39;ve specified in our vertex buffer objects. These Vertex Buffer Objects are typically held in a Vertex Array Object which I&#39;ve described in more detail here: &lt;b&gt;To Be Added&lt;/b&gt;&lt;/p&gt;

&lt;h3&gt;2. The Tessellation Shading Stage&lt;/h3&gt;

&lt;p&gt;An optional stage which can generate additional geometry within the OpenGL Pipeline.&lt;/p&gt;

&lt;h3&gt;3. Geometry Shading Stage&lt;/h3&gt;

&lt;p&gt;In this stage you have the ability to generate yet more geometry from an input primitive, or convert the type of geometric primitive i.e converting triangles to lines. &lt;/p&gt;

&lt;h3&gt;4. The Fragment Shading Stage&lt;/h3&gt;

&lt;p&gt;The last part of the shading pipeline processes the individual fragments generated by OpenGL&#39;s rasterizer and must also have a shader bound to it. In practice this means that for a very basic example we need only provide a vertex and a fragment shader in order for us to have a working shader pipeline.&lt;/p&gt;

&lt;h3&gt;5. The Compute Shading Stage&lt;/h3&gt;

&lt;p&gt;This isn&#39;t a part of the graphical pipeline in the same way as the stages above and stands separate. In this stage we can do things like compute post-processing effects.&lt;/p&gt;

&lt;h2&gt;Writing Our First Shader Program&lt;/h2&gt;

&lt;p&gt;Now that you&#39;ve got a little bit of an understanding of what a shader program is, it&#39;s time to start analyzing the code that goes into making a simple shader.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// here we specify the version using #version
#version 330 core

// our shader programs entry point, this is the same for 
// every shader program we will be writing.
void main()
{
   // all processing code goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Universal Variables&lt;/h3&gt;

&lt;p&gt;Being a typed language, every variable must be declared and have an associated type. All data for our shaders is passed using special global variables. These are entirely separate from any global variables set in your applications code and automatically get passed to the next stage of the programmable pipeline.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#version 330 core

// our global input
in vec4 vColor;

// out global output that gets passed to the next
// stage of the rendering pipeline
out vec4 color;

void
main()
{
    color = vColor;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example we take in a color global variable and then set our output so that it get&#39;s passed to the next section of our programmable pipeline.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Managing Game States With LWJGL 3</title>
      <link>https://tutorialedge.net/post/java/lwjgl3/managing-game-state-with-lwjgl3/</link>
      <pubDate>Sat, 15 Apr 2017 08:23:18 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/java/lwjgl3/managing-game-state-with-lwjgl3/</guid>
      <description>&lt;p&gt;Managing game states effectively in any game can sometimes be tricky and if not done properly from the outset, can lead to a tangled mess of spaghetti code that’s almost unmaintainable. In this tutorial I’m hopefully going to be helping to prevent any of these problems from arising in your own personal game development projects. For the purpose of this tutorial I’ll be using Java and the OpenGL wrapper library LWJGL3 in order to demonstrate how to effectively manage game states.&lt;/p&gt;

&lt;h2&gt;The Design&lt;/h2&gt;

&lt;p&gt;So straight away I know I want to have a game that has a main menu, as well as the ability to pause and play and possibly a movie state that allows me to show in-game cinematics or something to that effect. So from this we’ll create the following states: MENU, PLAY, PAUSE, MOVIE&lt;p&gt;

&lt;h2&gt;The Implementation&lt;/h2&gt;

&lt;p&gt;In Java we can easily represent these states like so using an enum: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private enum State {
    MENU, PLAY, PAUSE, MOVIE 
};

private static State gameState = State.MENU;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we’ve declared what states we want and initialized what state we are in on startup, we can then add some form of logic to our update and render functions that allow us to choose when and where to update and render different aspects of our game. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public void update() {
        handleInput();
        
        switch(gameState) {
            case MENU:
                // update all menu stuff
                break;
            case PLAY:
                // update our player object and allow us to play
                player1.update();
                break;
                
            case PAUSE:
                // stop updating our game objects and essentially do nothing
                break;
                
            case MOVIE:
                // Play any movie clips...
                break;
                
            default:
                break;  
        }
        
    }
    
    public void render() {
        
        switch(gameState){
            case MENU:
                // Just show our background, we can add some cool menus and stuff
                // here but for now I&#39;m keeping it simple.
                bg.render();
                break;
            case PLAY:
                // Render both our player and background and in update switch
                // we enable player1.update()
                bg.render();
                player1.render();
                break;
            case PAUSE:
                // Render our player and background but don&#39;t allow them to
                // update
                bg.render();
                player1.render();
                break;
            case MOVIE:
                // Play any movie clips...
                break;
            default:
                // Switch cases should almost always have a default case
                // this is so that it catches any unexpected values although.
                break;
        }
        
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;h2&gt;Switching States&lt;/h2&gt;
&lt;p&gt;As a means of switching states, I’ve created a simple method in my game class that checks to see whether any of the main keys I have defined for switching states have been pressed.&lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void handleInput(){
		if(KeyboardHandler.isKeyDown(GLFW.GLFW_KEY_SPACE)){
			gameState = State.PLAY;
		}
		if(KeyboardHandler.isKeyDown(GLFW.GLFW_KEY_P)){
			System.err.println(&amp;quot;Pausing Play...&amp;quot;);
			gameState = State.PAUSE;
		}
		if(KeyboardHandler.isKeyDown(GLFW.GLFW_KEY_R)){
			gameState = State.PLAY;
			System.err.println(&amp;quot;Resuming Play...&amp;quot;);
		}
		if(KeyboardHandler.isKeyDown(GLFW.GLFW_KEY_ESCAPE)){
			gameState = State.MENU;
		}
	}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>