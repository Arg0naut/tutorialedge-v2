<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lwjgl3 on TutorialEdge.net</title>
    <link>https://tutorialedge.net/tags/lwjgl3/index.xml</link>
    <description>Recent content in Lwjgl3 on TutorialEdge.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://tutorialedge.net/tags/lwjgl3/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Getting Started with LWJGL 3 and OpenGL</title>
      <link>https://tutorialedge.net/post/java/lwjgl3/getting-started-java-lwjgl3/</link>
      <pubDate>Sat, 15 Apr 2017 09:54:44 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/java/lwjgl3/getting-started-java-lwjgl3/</guid>
      <description>&lt;p&gt;&lt;b&gt;&lt;i&gt;Note: This guide is still under construction so please refer back to it often for more articles.&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Welcome to the ultimate comprehensive guide to getting started with LWJGL 3 and OpenGL. My main goal for this part of the site is to create the ultimate primer from which game developers can refer to.&lt;/p&gt;

&lt;h4&gt;Beginners Tutorials:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorialedge.net/setting-up-eclipse-with-lwgjl3-and-opengl&#34;&gt;Setting up Eclipse to use LWJGL3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorialedge.net/creating-game-window-tutorial-02-programming-2d-endless-runner&#34;&gt;Creating a Game Window with GLFW&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Beginners guide to Matrices and Vectors&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorialedge.net/lwjgl-3-fps-main-game-loop&#34;&gt;Creating a Game Loop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Creating your First Triangle&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorialedge.net/initializing-opengl-with-lwjgl3-and-java&#34;&gt;Getting Started with OpenGL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vertex Array Object and Vertex Buffer Objects&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Intermediate Tutorials&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorialedge.net/getting-started-with-opengl-shaders&#34;&gt;Introduction to Shaders&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorialedge.net/lwjgl-3-orthographic-camera-tutorial&#34;&gt;Orthographic Camera Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Perspective Camera Tutorial&lt;/li&gt;
&lt;li&gt;Input Handling Tutorial&lt;/li&gt;
&lt;li&gt;Texturing with LWJGL 3&lt;/li&gt;
&lt;li&gt;Getting Started with OpenAL and in-game Audio&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Advanced Tutorials&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Ray Tracing with OpenGL&lt;/li&gt;
&lt;li&gt;More to be Added...&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>LWJGL 3 Mouse Current Position Tutorial</title>
      <link>https://tutorialedge.net/post/java/lwjgl3/lwjgl-3-mouse-current-position-tutorial/</link>
      <pubDate>Sat, 15 Apr 2017 09:43:47 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/java/lwjgl3/lwjgl-3-mouse-current-position-tutorial/</guid>
      <description>&lt;p&gt;In this tutorial I will be showing you how you can obtain the X and Y coordinates of the Mouse cursor in an applications window and print it out to the console.&lt;/p&gt;

&lt;h2&gt;Creating a MouseHandler Class&lt;/h2&gt;

&lt;p&gt;To begin with I recommend you create an &amp;lsquo;Input&amp;rsquo; package within your project as this is a good way to keep all Input Handler classes organized within your projects. Once you&amp;rsquo;ve created this package, right click on it and add a new class called MouseHandler. This class will extend the GLFWCursorPosCallback abstract class provided by the LWJGL3 framework.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Input;

import org.lwjgl.glfw.GLFWCursorPosCallback;

// Our MouseHandler class extends the abstract class
// abstract classes should never be instantiated so here
// we create a concrete that we can instantiate
public class MouseHandler extends GLFWCursorPosCallback {

  @Override
  public void invoke(long window, double xpos, double ypos) {
    // TODO Auto-generated method stub
    // this basically just prints out the X and Y coordinates 
    // of our mouse whenever it is in our window
    System.out.println(&amp;quot;X: &amp;quot; + xpos + &amp;quot; Y: &amp;quot; + ypos);
  }	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Making it Work&lt;/h2&gt;

&lt;p&gt;Now that we&amp;rsquo;ve created our MouseHandler class we need to put in the following code just below our GLFW Window initialization so that our invoke method will be called every time the cursor&amp;rsquo;s position changes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;glfwSetCursorPosCallback(window, mouseCallback = new MouseHandler());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that should be it all done, you should now be seeing the cursors position outputted to the console.&lt;/p&gt;

&lt;p&gt;&lt;img style=&#34;width: 100%; height: auto;&#34; src=&#34;https://tutorialedge.net/uploads/articles/cursor-pos-console.PNG&#34; /&gt;&lt;/p&gt;

&lt;h2&gt;Main Class&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.lwjgl.Sys;
import org.lwjgl.glfw.*;
import org.lwjgl.opengl.*;

import Input.KeyboardHandler;
import Input.MouseHandler;

import java.nio.ByteBuffer;
 

import static org.lwjgl.glfw.Callbacks.*;
import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.system.MemoryUtil.*;
 
public class HelloWorld {
 
  // We need to strongly reference callback instances.
  private GLFWErrorCallback errorCallback;
  private GLFWKeyCallback   keyCallback;
  private GLFWCursorPosCallback mouseCallback;

  // The window handle
  private long window;

  public void run() {
    System.out.println(&amp;quot;Hello LWJGL &amp;quot; + Sys.getVersion() + &amp;quot;!&amp;quot;);

    try {
      init();
      loop();

      // Release window and window callbacks
      glfwDestroyWindow(window);
      keyCallback.release();
    } finally {
      // Terminate GLFW and release the GLFWerrorfun
      glfwTerminate();
      errorCallback.release();
    }
  }

  private void init() {
    // Setup an error callback. The default implementation
    // will print the error message in System.err.
    glfwSetErrorCallback(errorCallback = errorCallbackPrint(System.err));

    // Initialize GLFW. Most GLFW functions will not work before doing this.
    if ( glfwInit() != GL11.GL_TRUE )
      throw new IllegalStateException(&amp;quot;Unable to initialize GLFW&amp;quot;);

    // Configure our window
    glfwDefaultWindowHints(); // optional, the current window hints are already the default
    glfwWindowHint(GLFW_VISIBLE, GL_FALSE); // the window will stay hidden after creation
    glfwWindowHint(GLFW_RESIZABLE, GL_TRUE); // the window will be resizable

    int WIDTH = 300;
    int HEIGHT = 300;

    // Create the window
    window = glfwCreateWindow(WIDTH, HEIGHT, &amp;quot;Hello World!&amp;quot;, NULL, NULL);
    if ( window == NULL )
      throw new RuntimeException(&amp;quot;Failed to create the GLFW window&amp;quot;);

    // Setup a key callback. It will be called every time a key is pressed, repeated or released.
    glfwSetKeyCallback(window, keyCallback = new KeyboardHandler());


    glfwSetCursorPosCallback(window, mouseCallback = new MouseHandler());

    // Get the resolution of the primary monitor
    ByteBuffer vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor());
    // Center our window
    glfwSetWindowPos(
      window,
      (GLFWvidmode.width(vidmode) - WIDTH) / 2,
      (GLFWvidmode.height(vidmode) - HEIGHT) / 2
    );

    // Make the OpenGL context current
    glfwMakeContextCurrent(window);
    // Enable v-sync
    glfwSwapInterval(1);

    // Make the window visible
    glfwShowWindow(window);
  }
  
  public void update(){
    if(KeyboardHandler.isKeyDown(GLFW_KEY_SPACE))
      System.out.println(&amp;quot;Space Key Pressed&amp;quot;);
  }

  private void loop() {
    // This line is critical for LWJGL&#39;s interoperation with GLFW&#39;s
    // OpenGL context, or any context that is managed externally.
    // LWJGL detects the context that is current in the current thread,
    // creates the ContextCapabilities instance and makes the OpenGL
    // bindings available for use.
    GLContext.createFromCurrent();

    // Set the clear color
    glClearColor(1.0f, 0.0f, 0.0f, 0.0f);

    // Run the rendering loop until the user has attempted to close
    // the window or has pressed the ESCAPE key.
    while ( glfwWindowShouldClose(window) == GL_FALSE ) {
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer

      glfwSwapBuffers(window); // swap the color buffers

      // Poll for window events. The key callback above will only be
      // invoked during this call.
      glfwPollEvents();
      
      update();
        
    }
  }

  public static void main(String[] args) {
    new HelloWorld().run();
  }
 
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LWJGL 3 Keyboard Input Handler Tutorial</title>
      <link>https://tutorialedge.net/post/java/lwjgl3/lwjgl-3-keyboard-input-handler-tutorial/</link>
      <pubDate>Sat, 15 Apr 2017 09:42:07 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/java/lwjgl3/lwjgl-3-keyboard-input-handler-tutorial/</guid>
      <description>&lt;p&gt;This tutorial looks to demonstrate how you can extend the lightweight java game library in order to create your own input handlers which can be used in your games as a means for handling keyboard and mouse input.&lt;/p&gt;

&lt;h2&gt;The Observer Design Pattern&lt;/h2&gt;

&lt;p&gt;The programmers who developed LWJGL 3 have used an observer design pattern as a way to implement input. The works by having one part of the system listening for input through all the various input devices whilst also keeping a list of classes that should be notified every time an event takes place. This has been explained in more detail in a tutorial dedicated to the Observer Design Pattern which I recommend if you wish to help improve your overall understanding of how LWJGL 3 works.&lt;/p&gt;

&lt;h2&gt;Creating a Keyboard Handler&lt;/h2&gt;

&lt;p&gt;In order to keep the project tidy I recommend you create a new Package within your project and call it &#34;Input&#34; or something meaningful to that effect. Create a new class within this Package called KeyboardHandler. This KeyboardHandler class will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package Input;

import org.lwjgl.glfw.GLFWKeyCallback;
import static org.lwjgl.glfw.GLFW.*;

public class KeyboardHandler extends GLFWKeyCallback{

  public static boolean[] keys = new boolean[65536];

  // The GLFWKeyCallback class is an abstract method that
  // can&#39;t be instantiated by itself and must instead be extended
  // 
  @Override
  public void invoke(long window, int key, int scancode, int action, int mods) {
    // TODO Auto-generated method stub
    keys[key] = action != GLFW_RELEASE;
  }

  // boolean method that returns true if a given key
  // is pressed.
  public static boolean isKeyDown(int keycode) {
    return keys[keycode];
  }
	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Making it Work&lt;/h2&gt;

&lt;p&gt;Now that we&#39;ve got our input handler class it&#39;s time to register our new class as a listener in the class that deals with OpenGL and GLFW initialization as this is where we will have to register our newly built class as a listener. At the top of your class add an declaration of the GLFWKeyCallback class like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// This prevents our window from crashing later on.
private GLFWKeyCallback keyCallback;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&#39;ve instantiated our keyCallBack class we can set this to equal our newly built KeyboardHandler class like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Sets our keycallback to equal our newly created Input class()
glfwSetKeyCallback(window, keyCallback = new KeyboardHandler());		
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Checking it Works&lt;/h2&gt;

&lt;p&gt;Now that we&#39;ve implemented our own KeyboardHandler class it&#39;s time to check to see if it works. We can do this by adding the following to our Update() function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void update(){
  if(KeyboardHandler.isKeyDown(GLFW_KEY_SPACE))
    System.out.println(&amp;quot;Space Key Pressed&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Main Class&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.lwjgl.Sys;
import org.lwjgl.glfw.*;
import org.lwjgl.opengl.*;

import Input.KeyboardHandler;

import java.nio.ByteBuffer;
 

import static org.lwjgl.glfw.Callbacks.*;
import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.system.MemoryUtil.*;
 
public class HelloWorld {
 
    // We need to strongly reference callback instances.
    private GLFWErrorCallback errorCallback;
    private GLFWKeyCallback   keyCallback;
 
    // The window handle
    private long window;
 
    public void run() {
        System.out.println(&amp;quot;Hello LWJGL &amp;quot; + Sys.getVersion() + &amp;quot;!&amp;quot;);
 
        try {
            init();
            loop();
 
            // Release window and window callbacks
            glfwDestroyWindow(window);
            keyCallback.release();
        } finally {
            // Terminate GLFW and release the GLFWerrorfun
            glfwTerminate();
            errorCallback.release();
        }
    }
 
    private void init() {
        // Setup an error callback. The default implementation
        // will print the error message in System.err.
        glfwSetErrorCallback(errorCallback = errorCallbackPrint(System.err));
 
        // Initialize GLFW. Most GLFW functions will not work before doing this.
        if ( glfwInit() != GL11.GL_TRUE )
            throw new IllegalStateException(&amp;quot;Unable to initialize GLFW&amp;quot;);
 
        // Configure our window
        glfwDefaultWindowHints(); // optional, the current window hints are already the default
        glfwWindowHint(GLFW_VISIBLE, GL_FALSE); // the window will stay hidden after creation
        glfwWindowHint(GLFW_RESIZABLE, GL_TRUE); // the window will be resizable
 
        int WIDTH = 300;
        int HEIGHT = 300;
 
        // Create the window
        window = glfwCreateWindow(WIDTH, HEIGHT, &amp;quot;Hello World!&amp;quot;, NULL, NULL);
        if ( window == NULL )
            throw new RuntimeException(&amp;quot;Failed to create the GLFW window&amp;quot;);
 
        // Setup a key callback. It will be called every time a key is pressed, repeated or released.
        glfwSetKeyCallback(window, keyCallback = new KeyboardHandler());
 
        // Get the resolution of the primary monitor
        ByteBuffer vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor());
        // Center our window
        glfwSetWindowPos(
            window,
            (GLFWvidmode.width(vidmode) - WIDTH) / 2,
            (GLFWvidmode.height(vidmode) - HEIGHT) / 2
        );
 
        // Make the OpenGL context current
        glfwMakeContextCurrent(window);
        // Enable v-sync
        glfwSwapInterval(1);
 
        // Make the window visible
        glfwShowWindow(window);
    }
    
    public void update(){
    	if(KeyboardHandler.isKeyDown(GLFW_KEY_SPACE))
    		System.out.println(&amp;quot;Space Key Pressed&amp;quot;);
    }
 
    private void loop() {
        // This line is critical for LWJGL&#39;s interoperation with GLFW&#39;s
        // OpenGL context, or any context that is managed externally.
        // LWJGL detects the context that is current in the current thread,
        // creates the ContextCapabilities instance and makes the OpenGL
        // bindings available for use.
        GLContext.createFromCurrent();
 
        // Set the clear color
        glClearColor(1.0f, 0.0f, 0.0f, 0.0f);
 
        // Run the rendering loop until the user has attempted to close
        // the window or has pressed the ESCAPE key.
        while ( glfwWindowShouldClose(window) == GL_FALSE ) {
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer
 
            glfwSwapBuffers(window); // swap the color buffers
 
            // Poll for window events. The key callback above will only be
            // invoked during this call.
            glfwPollEvents();
            
            update();
            
        }
    }
 
    public static void main(String[] args) {
        new HelloWorld().run();
    }
 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Video Tutorial&lt;/h2&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/_6b73ZxlQOg&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>LWJGL 3 Orthographic Camera Tutorial</title>
      <link>https://tutorialedge.net/post/java/lwjgl3/lwjgl-3-orthographic-camera-tutorial/</link>
      <pubDate>Sat, 15 Apr 2017 09:39:43 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/java/lwjgl3/lwjgl-3-orthographic-camera-tutorial/</guid>
      <description>&lt;p&gt;This tutorial leads on from some of the topics covered in my previous tutorial : How Matrices are used in Game Development so if you haven’t got a good grounding in matrices then I suggest you check that out first. There are several YouTube videos out there that expertly cover the topic of matrices as well so check them out!&lt;/p&gt;

&lt;h2&gt;Orthographic Projection Camera&lt;/h2&gt;

&lt;p&gt;Orthographic cameras are a means of representing 3D points in our game world on a 2D monitor/screen. This basically means that you see objects moving away from the camera getting smaller and thus this is perfect for our 2D games. One of the key things you have to understand from the beginning is that there is no ‘physical’ camera object, the camera is basically represented by a matrix that we can translate, rotate or scale depending on however we need to move the camera.&lt;/p&gt;

&lt;p&gt;In this tutorial we will be building the basic Orthographic projection matrix that is primarily used in 2D games. This orthographic matrix is one of the simplest camera matrices and doesn’t show any form of perspective to our objects in our scenes. Without any form of perspective we will never see objects getting smaller as they go further into the distance, but seeing as 2D games are only represented in terms of X and Y coordinates we don’t tend to worry about perspective in our scenes.&lt;/p&gt;

&lt;p&gt;To create an orthographic matrix we will need 6 float variables:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;left&lt;/li&gt;
&lt;li&gt;right&lt;/li&gt;
&lt;li&gt;bottom&lt;/li&gt;
&lt;li&gt;top&lt;/li&gt;
&lt;li&gt;near&lt;/li&gt;
&lt;li&gt;far&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These will represent the positions of the clipping planes.&lt;/p&gt;

&lt;h2&gt;Representing our Matrix in Code:&lt;/h2&gt;

&lt;p&gt;I wont go into the specifics of how these matrices work as I’m pretty sure there are a hundred different YouTube videos that go to great lengths to describe these things, but I will go onto say that all of this code follows Column-major order just to avoid confusion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Gives us our orthographic matrix
  public static Matrix4f orthographic(float left, float right, float bottom, float top, float near, float far){
  Matrix4f matrix = new Matrix4f();

  matrix.elements[0 + 0 * 4] = 2.0f / (right - left);
  matrix.elements[1 + 1 * 4] = 2.0f / (top - bottom);
  matrix.elements[2 + 2 * 4] = 2.0f / (near - far);

  matrix.elements[0 + 3 * 4] = (left + right) / (left - right);
  matrix.elements[1 + 3 * 4] = (bottom + top) / (bottom - top);
  matrix.elements[2 + 3 * 4] = (far + near) / (far - near);

  matrix.elements[3 + 3 * 4] = 1.0f;

  return matrix;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By doing this we can now create a projection matrix in our initialization using this new method. In the demonstration code this is done like so in our main class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Matrix4f pr_matrix = Matrix4f.orthographic(-10.0f, 10.0f, -10.0f * 9.0f / 16.0f, 10.0f * 9.0f / 16.0f, -10.0f, 10.0f);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Creating Camera Controls&lt;/h2&gt;

&lt;p&gt;So now that we’ve got a matrix that will represent our projection matrix, we will also need some way of tracking and updating where our camera is in the world. We can do this by adding a Vector3f to our Camera class and calling it ‘position’. This will essentially store the coordinates of our camera and allow us to move the camera using the following update method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void update(){		
  if(Input.isKeyDown(GLFW_KEY_W)){
    position.y += 0.05f;
  }
  if(Input.isKeyDown(GLFW_KEY_S)){
    position.y -= 0.05f;
  }
  if(Input.isKeyDown(GLFW_KEY_D)){
    position.x += 0.05f;
  }
  if(Input.isKeyDown(GLFW_KEY_A)){
    position.x -= 0.05f;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Updating Every Model in our Game&lt;/h2&gt;

&lt;p&gt;The way that the game engine has been implemented is that every object currently uses the one shader which looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#version 330 core

layout ( location = 0 ) in vec4 position;
layout ( location = 1 ) in vec2 tc;

uniform mat4 pr_matrix;
uniform mat4 vw_matrix;
uniform mat4 ml_matrix = mat4(1.0);

out DATA
{
	vec2 tc;
} vs_out;

void main()
{
	gl_Position = pr_matrix * vw_matrix * ml_matrix * position;
	vs_out.tc = tc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By adding in the uniform mat4 variable vw_matrix, we can then pass our camera’s view matrix into our shader and multiply the gl_Position variable by the view matrix and update our camera.&lt;/p&gt;

&lt;p&gt;In order for us to pass in our view matrix to our shader we have added the following line to our Main class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Shader.shader1.setUniformMat4f(&amp;quot;vw_matrix&amp;quot;, Matrix4f.translate(camera.position));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;So that should be all you need to get yourself up and running with the demonstration code and your own orthographic projection matrix! If you feel you need more detail on the subject then please leave a comment in the comments section below and I’ll try my best to expand upon the explanations already given!&lt;/p&gt;

&lt;p&gt;You can find the repository for the example code here: &lt;a href=&#34;https://github.com/emforce/AlgebraTutorial&#34;&gt;Github Repo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating a Game Window using GLFW - LWJGL3</title>
      <link>https://tutorialedge.net/post/java/lwjgl3/creating-game-window-lwjgl3-glfw/</link>
      <pubDate>Sat, 15 Apr 2017 09:29:14 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/java/lwjgl3/creating-game-window-lwjgl3-glfw/</guid>
      <description>&lt;h2&gt;Creating our Game Window&lt;/h2&gt;

&lt;p&gt;So now that you’ve got the base project set up, you are going to want to start writing some code and making some magic happen on the screen.
First of all you are going to want to create a new class and call it Main.java. This will be the class that contains vital things like the initialization code and the main game loop which we will be developing later on.&lt;/p&gt;

&lt;p&gt;Once you’ve created the Main.java class you are going to want to write the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import static org.lwjgl.glfw.GLFW.*;

public class Main implements Runnable{

  private Thread thread;
  public boolean running = true;

  public static void Main(String args[]){
    Main game = new Main();
    game.start();
  }

  public void start(){
    running = true;
    thread = new Thread(this, &amp;quot;EndlessRunner&amp;quot;);
    thread.start();
  }

  public void init(){
    
  }

  public void update(){
    
  }

  public void render(){
    
  }

  @Override
  public void run() {
    init();
    while(running){
      update();
      render();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will form the main outline of our code and it’s a great place to start from. So far it’s all super simple stuff and all the code is really doing is starting our games thread, everything else still has to be fleshed out.&lt;/p&gt;

&lt;h2&gt;Our Imports&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import static org.lwjgl.glfw.GLFW.*; // allows us to create windows
import static org.lwjgl.opengl.GL11.*; // gives us access to things like &amp;quot;GL_TRUE&amp;quot; which we&#39;ll need 
import static org.lwjgl.system.MemoryUtil.*; // allows us to use &#39;NULL&#39; in our code, note this is slightly different from java&#39;s &#39;null&#39;
import java.nio.ByteBuffer; // Used for getting the primary monitor later on.
import org.lwjgl.glfw.GLFWvidmode; // again used for primary monitor stuff.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are the libraries we need to import in order for our basic window to be displayed.&lt;/p&gt;

&lt;h2&gt;The init() function&lt;/h2&gt;

&lt;p&gt;Our init function is where most of our initialization code will go for both the window and for OpenGL. It takes the following shape:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void init(){
  // Initializes our window creator library - GLFW 
  // This basically means, if this glfwInit() doesn&#39;t run properlly
  // print an error to the console
  if(glfwInit() != GL_TRUE){
    // Throw an error.
    System.err.println(&amp;quot;GLFW initialization failed!&amp;quot;);
  }
  
  // Allows our window to be resizable
  glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);
  
  // Creates our window. You&#39;ll need to declare private long window at the
  // top of the class though. 
  // We pass the width and height of the game we want as well as the title for
  // the window. The last 2 NULL parameters are for more advanced uses and you
  // shouldn&#39;t worry about them right now.
  window = glfwCreateWindow(width, height, &amp;quot;Endless Runner&amp;quot;, NULL, NULL);

  // This code performs the appropriate checks to ensure that the
  // window was successfully created. 
  // If not then it prints an error to the console
  if(window == NULL){
    // Throw an Error
    System.err.println(&amp;quot;Could not create our Window!&amp;quot;);
  }
  
  // creates a bytebuffer object &#39;vidmode&#39; which then queries 
  // to see what the primary monitor is. 
  ByteBuffer vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor());
  // Sets the initial position of our game window. 
  glfwSetWindowPos(window, 100, 100);
  // Sets the context of GLFW, this is vital for our program to work.
  glfwMakeContextCurrent(window);
  // finally shows our created window in all it&#39;s glory.
  glfwShowWindow(window);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Update() and Render() functions&lt;/h2&gt;

&lt;p&gt;Once we’ve successfully initialized both our window and GLFW we will now want to make sure that everything works correctly and that we’ll be able to get any input needed from the user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void update(){
  // Polls for any window events such as the window closing etc.
  glfwPollEvents();
}

public void render(){
  // Swaps out our buffers
  glfwSwapBuffers(window);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Our updated Game Loop&lt;/h2&gt;

&lt;p&gt;Now that everything is in place you will want to implement the code that allows us to close the window. This can be done by adding the following 3 lines of code under our call to render(); in the main game loop as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void run() {
  // All our initialization code
  init();
  // Our main game loop
  while(running){
    update();
    render();
    // Checks to see if either the escape button or the
    // red cross at the top were pressed.
    // if so sets our boolean to false and closes the
    // thread.
    if(glfwWindowShouldClose(window) == GL_TRUE){
      running = false;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Compile&lt;/h2&gt;

&lt;p&gt;Once you’ve done all that, try hitting the green ‘run as’ arrow button at the top of your Eclipse IDE or right clicking on your project and selecting ‘run as’ and then selecting ‘Java application’. If you’ve done everything correctly and have no errors then you should see a game window successfully appearing on your screen&lt;/p&gt;

&lt;h2&gt;Full Source:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.system.MemoryUtil.*;
import java.nio.ByteBuffer;
import org.lwjgl.glfw.GLFWvidmode;

public class Main implements Runnable{
	
  private Thread thread;
  public boolean running = true;

  private long window;

  private int width = 1200, height = 800;

  public static void main(String args[]){
    Main game = new Main();
    game.start();
  }

  public void start(){
    running = true;
    thread = new Thread(this, &amp;quot;EndlessRunner&amp;quot;);
    thread.start();
  }

  public void init(){
    // Initializes our window creator library - GLFW 
    // This basically means, if this glfwInit() doesn&#39;t run properlly
    // print an error to the console
    if(glfwInit() != GL_TRUE){
      // Throw an error.
      System.err.println(&amp;quot;GLFW initialization failed!&amp;quot;);
    }
    
    // Allows our window to be resizable
    glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);
    
    // Creates our window. You&#39;ll need to declare private long window at the
    // top of the class though. 
    // We pass the width and height of the game we want as well as the title for
    // the window. The last 2 NULL parameters are for more advanced uses and you
    // shouldn&#39;t worry about them right now.
    window = glfwCreateWindow(width, height, &amp;quot;Endless Runner&amp;quot;, NULL, NULL);

    // This code performs the appropriate checks to ensure that the
    // window was successfully created. 
    // If not then it prints an error to the console
    if(window == NULL){
      // Throw an Error
      System.err.println(&amp;quot;Could not create our Window!&amp;quot;);
    }
    
    // creates a bytebuffer object &#39;vidmode&#39; which then queries 
    // to see what the primary monitor is. 
    ByteBuffer vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor());
    // Sets the initial position of our game window. 
    glfwSetWindowPos(window, 100, 100);
    // Sets the context of GLFW, this is vital for our program to work.
    glfwMakeContextCurrent(window);
    // finally shows our created window in all it&#39;s glory.
    glfwShowWindow(window);
  }

  public void update(){
    // Polls for any window events such as the window closing etc.
    glfwPollEvents();
  }

  public void render(){
    // Swaps out our buffers
    glfwSwapBuffers(window);
  }

  @Override
  public void run() {
    // All our initialization code
    init();
    // Our main game loop
    while(running){
      update();
      render();
      // Checks to see if either the escape button or the
      // red cross at the top were pressed.
      // if so sets our boolean to false and closes the
      // thread.
      if(glfwWindowShouldClose(window) == GL_TRUE){
        running = false;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LWJGL 3 Main Game Loop Tutorial</title>
      <link>https://tutorialedge.net/post/java/lwjgl3/lwjgl-3-fps-main-game-loop/</link>
      <pubDate>Sat, 15 Apr 2017 09:29:14 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/java/lwjgl3/lwjgl-3-fps-main-game-loop/</guid>
      <description>&lt;p&gt;The code featured below is an example of how you create a game loop that is limited to 60 frames per second. This is useful if you have implemented update functions that are bounded by the number of times they are called rather than based on time between updates. &lt;/p&gt;

&lt;h2&gt;The Code&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public void run(){
	init();
	long lastTime = System.nanoTime();
	double delta = 0.0;
	double ns = 1000000000.0 / 60.0;
	long timer = System.currentTimeMillis();
	int updates = 0;
	int frames = 0;
	while(running){
		long now = System.nanoTime();
		delta += (now - lastTime) / ns;
		lastTime = now;
		if (delta &amp;gt;= 1.0) {
			update();
			updates++;
			delta--;
		}
		render();		
		frames++;
		if (System.currentTimeMillis() - timer &amp;gt; 1000) {
			timer += 1000;
			System.out.println(updates + &amp;quot; ups, &amp;quot; + frames + &amp;quot; fps&amp;quot;);
			updates = 0;
			frames = 0;
		}
		if(glfwWindowShouldClose(window) == GL_TRUE){
			running = false;
		}
	}
	
	cleanup();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Managing Game States With LWJGL 3</title>
      <link>https://tutorialedge.net/post/java/lwjgl3/managing-game-state-with-lwjgl3/</link>
      <pubDate>Sat, 15 Apr 2017 08:23:18 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/java/lwjgl3/managing-game-state-with-lwjgl3/</guid>
      <description>&lt;p&gt;Managing game states effectively in any game can sometimes be tricky and if not done properly from the outset, can lead to a tangled mess of spaghetti code that’s almost unmaintainable. In this tutorial I’m hopefully going to be helping to prevent any of these problems from arising in your own personal game development projects. For the purpose of this tutorial I’ll be using Java and the OpenGL wrapper library LWJGL3 in order to demonstrate how to effectively manage game states.&lt;/p&gt;

&lt;h2&gt;The Design&lt;/h2&gt;

&lt;p&gt;So straight away I know I want to have a game that has a main menu, as well as the ability to pause and play and possibly a movie state that allows me to show in-game cinematics or something to that effect. So from this we’ll create the following states: MENU, PLAY, PAUSE, MOVIE&lt;p&gt;

&lt;h2&gt;The Implementation&lt;/h2&gt;

&lt;p&gt;In Java we can easily represent these states like so using an enum: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private enum State {
    MENU, PLAY, PAUSE, MOVIE 
};

private static State gameState = State.MENU;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we’ve declared what states we want and initialized what state we are in on startup, we can then add some form of logic to our update and render functions that allow us to choose when and where to update and render different aspects of our game. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public void update() {
        handleInput();
        
        switch(gameState) {
            case MENU:
                // update all menu stuff
                break;
            case PLAY:
                // update our player object and allow us to play
                player1.update();
                break;
                
            case PAUSE:
                // stop updating our game objects and essentially do nothing
                break;
                
            case MOVIE:
                // Play any movie clips...
                break;
                
            default:
                break;  
        }
        
    }
    
    public void render() {
        
        switch(gameState){
            case MENU:
                // Just show our background, we can add some cool menus and stuff
                // here but for now I&#39;m keeping it simple.
                bg.render();
                break;
            case PLAY:
                // Render both our player and background and in update switch
                // we enable player1.update()
                bg.render();
                player1.render();
                break;
            case PAUSE:
                // Render our player and background but don&#39;t allow them to
                // update
                bg.render();
                player1.render();
                break;
            case MOVIE:
                // Play any movie clips...
                break;
            default:
                // Switch cases should almost always have a default case
                // this is so that it catches any unexpected values although.
                break;
        }
        
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;h2&gt;Switching States&lt;/h2&gt;
&lt;p&gt;As a means of switching states, I’ve created a simple method in my game class that checks to see whether any of the main keys I have defined for switching states have been pressed.&lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void handleInput(){
		if(KeyboardHandler.isKeyDown(GLFW.GLFW_KEY_SPACE)){
			gameState = State.PLAY;
		}
		if(KeyboardHandler.isKeyDown(GLFW.GLFW_KEY_P)){
			System.err.println(&amp;quot;Pausing Play...&amp;quot;);
			gameState = State.PAUSE;
		}
		if(KeyboardHandler.isKeyDown(GLFW.GLFW_KEY_R)){
			gameState = State.PLAY;
			System.err.println(&amp;quot;Resuming Play...&amp;quot;);
		}
		if(KeyboardHandler.isKeyDown(GLFW.GLFW_KEY_ESCAPE)){
			gameState = State.MENU;
		}
	}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>