<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on TutorialEdge.net</title>
    <link>/series/golang/index.xml</link>
    <description>Recent content in Golang on TutorialEdge.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/series/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Reading in Console Input in Golang</title>
      <link>/post/golang/reading-console-input-golang/</link>
      <pubDate>Sat, 15 Apr 2017 08:48:49 +0100</pubDate>
      
      <guid>/post/golang/reading-console-input-golang/</guid>
      <description>

&lt;p&gt;This is a quick and simple tutorial on how to read in console text input into your Go (GoLang) program. In this tutorial we&#39;ll be creating the basis for a very simple shell that will take in all user input and simply echo it back to the user.&lt;/p&gt;

&lt;h2 id=&#34;reading-in-full-sentences&#34;&gt;Reading in Full Sentences&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll use Go&amp;rsquo;s while loop equivalent of a for loop without any parameters to ensure our program continues on forever. In this example every time text is entered and then enter is pressed, we assign text to equal everything up to and including the &lt;code&gt;\n&lt;/code&gt; special character. If we want to do comparison on the string that has just been entered then we can use the strings.Replace method in order to remove this trailing &lt;code&gt;\n&lt;/code&gt; character with nothing and then do the comparison.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you want this to work on Windows Systems then you will have to do &lt;code&gt;text = strings.Replace(text, &amp;quot;\r\n&amp;quot;, &amp;quot;&amp;quot;, -1)&lt;/code&gt; as windows uses a different line ending compared to unix systems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;bufio&amp;quot;
  &amp;quot;fmt&amp;quot;
  &amp;quot;os&amp;quot;
  &amp;quot;strings&amp;quot;
)

func main() {

  reader := bufio.NewReader(os.Stdin)
  fmt.Println(&amp;quot;Simple Shell&amp;quot;)
  fmt.Println(&amp;quot;---------------------&amp;quot;)

  for {
    fmt.Print(&amp;quot;-&amp;gt; &amp;quot;)
    text, _ := reader.ReadString(&#39;\n&#39;)
    // convert CRLF to LF
    text = strings.Replace(text, &amp;quot;\n&amp;quot;, &amp;quot;&amp;quot;, -1)

    if strings.Compare(&amp;quot;hi&amp;quot;, text) == 0 {
      fmt.Println(&amp;quot;hello, Yourself&amp;quot;)
    }

  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll see in this example that whenever we enter the word &amp;ldquo;hi&amp;rdquo;, our strings.Compare method will then return a 0 and it will print out hello back.&lt;/p&gt;

&lt;h2 id=&#34;reading-single-utf-8-encoded-unicode-characters&#34;&gt;Reading Single UTF-8 Encoded Unicode Characters&lt;/h2&gt;

&lt;p&gt;If you want to simply read one unicode character from the command line then I recommend you use bufio.ReadRune like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;reader := bufio.NewReader(os.Stdin)
char, _, err := reader.ReadRune()

if err != nil {
  fmt.Println(err)
}

// print out the unicode value i.e. A -&amp;gt; 65, a -&amp;gt; 97
fmt.Println(char)

switch char {
case &#39;A&#39;:
  fmt.Println(&amp;quot;A Key Pressed&amp;quot;)
  break
case &#39;a&#39;:
  fmt.Println(&amp;quot;a Key Pressed&amp;quot;)
  break
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;using-bufio-s-scanner&#34;&gt;Using Bufio&amp;rsquo;s Scanner&lt;/h2&gt;

&lt;p&gt;A third way you could potentially read in input from the console in go is by creating a new scanner and passing os.Stdin just as we have done above creating new readers and then using scanner.Scan in order to read in from the console:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func scanner() {
  scanner := bufio.NewScanner(os.Stdin)
  for scanner.Scan() {
    fmt.Println(scanner.Text())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code will infinitely ask scan for input and echo back whatever is entered.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As you can see there are numerous ways to do this and the best solution depends on your particular needs. If you are only needing single character input then use ReadRune() or if you are wanting to read in full new line delimited sentences then ReadString is the way to go.&lt;/p&gt;

&lt;p&gt;I hope you found this tutorial useful and if you have any further questions then please let me know in the comments section below!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you enjoyed this post then you may like this one on &lt;a href=&#34;https://tutorialedge.net/executing-system-commands-with-golang&#34;&gt;Calling System Commands in Go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Executing System Commands With Golang</title>
      <link>/post/golang/executing-system-commands-with-golang/</link>
      <pubDate>Sat, 15 Apr 2017 08:47:48 +0100</pubDate>
      
      <guid>/post/golang/executing-system-commands-with-golang/</guid>
      <description>

&lt;p&gt;This tutorial is just a quick and simple tutorial as to how to execute system commands using Google&amp;rsquo;s GoLang programming language.&lt;/p&gt;

&lt;h2 id=&#34;official-documentation&#34;&gt;Official Documentation&lt;/h2&gt;

&lt;p&gt;The official documentation for executing system commands can be found under the exec package: &lt;a href=&#34;https://golang.org/pkg/os/exec/&#34;&gt;Exec Package&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;cross-compatibility-issues&#34;&gt;Cross Compatibility Issues&lt;/h2&gt;

&lt;p&gt;Please note that some of these commands may not work on your operating system. If you are trying to write code that is compatible on multiple platforms then it would be wise to select commands that only feature on all platforms. If this is unachievable then I recommend you add conditional logic to your program that executes a different system command depending on the system it&amp;rsquo;s executing on top of.&lt;/p&gt;

&lt;h4 id=&#34;checking-current-operating-system&#34;&gt;Checking Current Operating System&lt;/h4&gt;

&lt;p&gt;In order to check what operating system our code is running on we can use the runtime package and check the GOOS constant. This will return the operating system target:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    if runtime.GOOS == &amp;quot;windows&amp;quot; {
		fmt.Println(&amp;quot;Can&#39;t Execute this on a windows machine&amp;quot;)
	} else {
		execute()
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full list of GOOS variables can be found here: &lt;a href=&#34;https://golang.org/pkg/runtime/internal/sys/#GOOS&#34;&gt;Sys Package&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;Below is the absolute bare essentials as to how to execute a system command, I&amp;rsquo;ve stripped out all the error handling just to keep it simple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os/exec&amp;quot;
	&amp;quot;runtime&amp;quot;
)

func execute() {

  // here we perform the pwd command.
  // we can store the output of this in our out variable 
  // and catch any errors in err
	out, err := exec.Command(&amp;quot;pwd&amp;quot;).Output()

  // if there is an error with our execution
  // handle it here
	if err != nil {
		fmt.Printf(&amp;quot;%s&amp;quot;, err)
	}

	fmt.Println(&amp;quot;Command Successfully Executed&amp;quot;)
  // as the out variable defined above is of type []byte we need to convert
  // this to a string or else we will see garbage printed out in our console
  // this is how we convert it to a string
	output := string(out[:])

  // once we have converted it to a string we can then output it.
	fmt.Println(output)
}

func main() {

	fmt.Println(&amp;quot;Simple Shell&amp;quot;)
	fmt.Println(&amp;quot;---------------------&amp;quot;)

	if runtime.GOOS == &amp;quot;windows&amp;quot; {
		fmt.Println(&amp;quot;Can&#39;t Execute this on a windows machine&amp;quot;)
	} else {
		execute()
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;exit-codes&#34;&gt;Exit Codes&lt;/h2&gt;

&lt;p&gt;// to be added&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you found this tutorial useful or wish to ask anything extra then please feel free to do so in the comments section below!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating A Simple Web Server With Golang</title>
      <link>/post/golang/creating-simple-web-server-with-golang/</link>
      <pubDate>Sat, 15 Apr 2017 08:46:33 +0100</pubDate>
      
      <guid>/post/golang/creating-simple-web-server-with-golang/</guid>
      <description>

&lt;p&gt;In this tutorial we&amp;rsquo;ll be focusing on creating a very simple web server using the &lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;net/http&lt;/a&gt; package. If you&amp;rsquo;ve ever used something like Node&amp;rsquo;s ExpressJS or Python&amp;rsquo;s Tornado, then you should hopefully see some similarities to how things are handled.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-basic-web-server&#34;&gt;Creating a Basic Web Server&lt;/h2&gt;

&lt;p&gt;Ok, so to begin with we’ll create a very simple web server that will just return whatever the URL path is of your query. This will be a good base from which we can build on top of.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;html&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
)

func main() {

    http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, &amp;quot;Hello, %q&amp;quot;, html.EscapeString(r.URL.Path))
    })
    
    http.HandleFunc(&amp;quot;/hi&amp;quot;, func(w http.ResponseWriter, r *http.Request){
        fmt.Fprintf(w, &amp;quot;Hi&amp;quot;)
    })

    log.Fatal(http.ListenAndServe(&amp;quot;:8081&amp;quot;, nil))

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above code we essentially define two different Handlers. These handlers are what respond to any http request that match the string pattern we define as the first parameter. So essentially whenever a request is made for the home page or &lt;em&gt;&lt;a href=&#34;http://localhost:8081/&#34;&gt;http://localhost:8081/&lt;/a&gt;&lt;/em&gt;, we&amp;rsquo;ll see our first handler respond as the query matches that pattern.&lt;/p&gt;

&lt;h2 id=&#34;running-our-server&#34;&gt;Running Our Server&lt;/h2&gt;

&lt;p&gt;Ok so now that we&amp;rsquo;ve created our own very simplistic server we can try running it by typing go run server.go into our console. This usually asks me for permission so accept that and then head over to your browser and head to &lt;a href=&#34;http://localhost:8081/world&#34;&gt;http://localhost:8081/world&lt;/a&gt;. On this page you should hopefully see your query string echoed back to you in true &amp;ldquo;hello world&amp;rdquo; fashion.&lt;/p&gt;

&lt;h2 id=&#34;adding-a-bit-of-complexity&#34;&gt;Adding a bit of Complexity&lt;/h2&gt;

&lt;p&gt;So now that we&amp;rsquo;ve got a basic web server set up, let&amp;rsquo;s try incrementing a counter every time a specific url is hit. Due to the fact that the web server is asynchronous, we&amp;rsquo;ll have to guard our counter using a mutex in order to prevent us from being hit with race-condition bugs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;sync&amp;quot;
)

var counter int
var mutex = &amp;amp;sync.Mutex{}

func echoString(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &amp;quot;hello&amp;quot;)
}

func incrementCounter(w http.ResponseWriter, r *http.Request) {
	mutex.Lock()
	counter++
	fmt.Fprintf(w, strconv.Itoa(counter))
	mutex.Unlock()
}

func main() {
	http.HandleFunc(&amp;quot;/&amp;quot;, echoString)

	http.HandleFunc(&amp;quot;/increment&amp;quot;, incrementCounter)

	http.HandleFunc(&amp;quot;/hi&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, &amp;quot;Hi&amp;quot;)
	})

	log.Fatal(http.ListenAndServe(&amp;quot;:8081&amp;quot;, nil))

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run this and then navigate to &lt;a href=&#34;http://localhost:8081/increment&#34;&gt;http://localhost:8081/increment&lt;/a&gt; and you should see the current count which will be locked, incremented and then unlocked every time you make a request to that page.&lt;/p&gt;

&lt;h2 id=&#34;serving-static-files&#34;&gt;Serving Static Files&lt;/h2&gt;

&lt;p&gt;Ok, so now that we&amp;rsquo;ve set up a simple server in go, it&amp;rsquo;s time to start serving some static files. Create a static folder within your project&amp;rsquo;s directory and then create some simple html files. For this example I&amp;rsquo;m just serving back the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;Hello World&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;h2&amp;gt;Hello World!&amp;lt;/h2&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you&amp;rsquo;ve got this then we can then modify our web server code to use the http.ServeFile method. Essentially this will take in the url of the request made to the server, and if it contains say index.html then it would return the index.html file, rendered as html in the browser. If we were to create an edit.html page and send a request to &lt;a href=&#34;http://localhost:8081/edit.html&#34;&gt;http://localhost:8081/edit.html&lt;/a&gt; then it would return whatever html content you choose to put in that edit.html page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func main() {

	http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, r.URL.Path[1:])
	})

	http.HandleFunc(&amp;quot;/hi&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, &amp;quot;Hi&amp;quot;)
	})

	log.Fatal(http.ListenAndServe(&amp;quot;:8081&amp;quot;, nil))

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;checking-it-works&#34;&gt;Checking it Works&lt;/h2&gt;

&lt;p&gt;Again run the server and navigate to &lt;a href=&#34;http://localhost:8081/index.html&#34;&gt;http://localhost:8081/index.html&lt;/a&gt; and you should hopefully see your very simple index.html file rendered in all it&amp;rsquo;s glory.&lt;/p&gt;

&lt;p&gt;I hope you found this tutorial useful and if you did then please let me know in the comments section below! This is part one of a series of GoLang tutorials in which we play around with APIs and creating servers so stay tuned for more!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Recommended Reading: If you wanted to say display a blog then connecting to a database is vital: &lt;a href=&#34;https://tutorialedge.net/go-mysql-tutorials&#34;&gt;Go MySQL Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Creating a RESTful API With Golang</title>
      <link>/post/golang/creating-restful-api-with-golang/</link>
      <pubDate>Sat, 15 Apr 2017 08:45:15 +0100</pubDate>
      
      <guid>/post/golang/creating-restful-api-with-golang/</guid>
      <description>

&lt;h2&gt;REST Architectures&lt;/h2&gt;

&lt;p&gt;REST is everywhere these days, from web sites to enterprise applications, the RESTful architecture style is a powerful way of providing communication between various moving by separate software components. Building REST APIs allow you to easily decouple both consumers and producers and are typically stateless by design. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you wish to learn more about the basics of REST APIs then check out &lt;a href=&#34;https://tutorialedge.net/what-are-restful-apis&#34;&gt;What Are RESTful APIs?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;JSON&lt;/h4&gt;

&lt;p&gt;For the purpose of this tutorial we’ll be using JavaScript Object Notation as a means of sending and receiving all information and thankfully Go comes with some excellent support for encoding and decoding these formats using the standard library package, encoding/json. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For more information on the encoding/json package check out the official documentation: &lt;a href=&#34;https://golang.org/pkg/encoding/json/&#34; target=&#34;_blank&#34;&gt;encoding/json&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;Marshalling&lt;/h4&gt;

&lt;p&gt;In order for us to easily We can easily convert data structures in GO into JSON by using something called marshalling which produces a byte slice containing a very long string with no extraneous white space. &lt;/p&gt;

&lt;h2&gt;A Basic Web Server&lt;/h2&gt;

&lt;p&gt;In order for a consumer to consume our API we’ll need to set up some form of server which will constantly listen on our local machine for now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you want a more in-depth tutorial on how to create a go based web server then check out this tutorial here: &lt;a href=&#34;http://tutorialedge.net/creating-a-simple-web-server-with-go-golang&#34;&gt;Creating a Simple Web Server with Go(Lang)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
)

func homePage(w http.ResponseWriter, r *http.Request){
    fmt.Fprintf(w, &amp;quot;Welcome to the HomePage!&amp;quot;)
    fmt.Println(&amp;quot;Endpoint Hit: homePage&amp;quot;)
}

func returnArticle(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &amp;quot;returns a specific article&amp;quot;)
    fmt.Println(&amp;quot;Endpoint Hit: returnArticle&amp;quot;)
}

func returnAllArticles(w http.ResponseWriter, r *http.Request){
    fmt.Fprintf(w, &amp;quot;All Articles&amp;quot;)
    fmt.Println(&amp;quot;Endpoint Hit: returnAllArticles&amp;quot;)
}

func addArticle(w http.ResponseWriter, r *http.Request){
    fmt.Fprintf(w, &amp;quot;Adds an article to list of articles&amp;quot;)
    fmt.Println(&amp;quot;Endpoint Hit: addArticle&amp;quot;)
}

func delArticle(w http.ResponseWriter, r *http.Request){
    fmt.Fprintf(w, &amp;quot;deletes a specific article&amp;quot;)
    fmt.Println(&amp;quot;Endpoint Hit: delArticle&amp;quot;)
}

func handleRequests() {
    http.HandleFunc(&amp;quot;/&amp;quot;, homePage)
    http.HandleFunc(&amp;quot;/all&amp;quot;, returnAllArticles)
    http.HandleFunc(&amp;quot;/single&amp;quot;, returnArticle)
    http.HandleFunc(&amp;quot;/delete&amp;quot;, delArticle)
    http.HandleFunc(&amp;quot;/add&amp;quot;, addArticle)
    log.Fatal(http.ListenAndServe(&amp;quot;:8081&amp;quot;, nil))
}

func main() {
    handleRequests()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Our Articles Structure&lt;/h2&gt;

&lt;p&gt;Once we’ve set up all the endpoints to our API, we can proceed to create a basic model that will store our articles for us and enable us to then encode this into a JSON format and return it via an endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Article struct {
    Title string `json:&amp;quot;Title&amp;quot;`
    Desc string `json:&amp;quot;desc&amp;quot;`
    Content string `json:&amp;quot;content&amp;quot;`
}

type Articles []Article 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Retrieving All Articles&lt;/h2&gt;

&lt;p&gt;We’ve now got everything we need in order to start mocking up some data and returning it. Add &lt;b&gt;“encoding/json”&lt;/b&gt; to your list of imports at the top of the file and then navigate to the &lt;b&gt;returnAllArticles&lt;/b&gt; function and then add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func returnAllArticles(w http.ResponseWriter, r *http.Request){
    articles := Articles{
        Article{Title: &amp;quot;Hello&amp;quot;, Desc: &amp;quot;Article Description&amp;quot;, Content: &amp;quot;Article Content&amp;quot;},
        Article{Title: &amp;quot;Hello 2&amp;quot;, Desc: &amp;quot;Article Description&amp;quot;, Content: &amp;quot;Article Content&amp;quot;},
    }    
    fmt.Println(&amp;quot;Endpoint Hit: returnAllArticles&amp;quot;)
    
    json.NewEncoder(w).Encode(articles)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run this and then open up http://localhost:8081/all in your browser and you should see a json representation of your list of articles like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[{&amp;quot;Title&amp;quot;:&amp;quot;Hello&amp;quot;,&amp;quot;desc&amp;quot;:&amp;quot;Article Description&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Article Content&amp;quot;},{&amp;quot;Title&amp;quot;:&amp;quot;Hello 2&amp;quot;,&amp;quot;desc&amp;quot;:&amp;quot;Article Description&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Article Content&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Getting Started with Routers&lt;/h2&gt;

&lt;p&gt;Now the standard library is adequate at providing everything you need to get your own simple REST api up and running but now that we’ve got the basic concepts down I feel it’s time to introduce third-party router packages. The most notable and highly used is the &lt;a href=&#34;https://github.com/gorilla/mux&#34; target=&#34;_blank&#34;&gt;gorilla/mux router&lt;/a&gt; which, as it stands currently has 2,281 stars on github.&lt;/p&gt;

&lt;h5&gt;Building our Router&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;github.com/gorilla/mux&amp;quot;
)

… // Existing code from above
func handleRequests() {
    
    myRouter := mux.NewRouter().StrictSlash(true)
    myRouter.HandleFunc(&amp;quot;/&amp;quot;, homePage)
    myRouter.HandleFunc(&amp;quot;/all&amp;quot;, returnAllArticles)
    log.Fatal(http.ListenAndServe(&amp;quot;:10000&amp;quot;, myRouter))
}

func main() {
    fmt.Println(&amp;quot;Rest API v2.0 - Mux Routers&amp;quot;)
    handleRequests()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Path Variables&lt;/h5&gt;

&lt;p&gt;So far so good, we’ve created a very simple REST API that returns a homepage and all our Articles. But what happens if we want to just view one article? Well thanks to the gorilla mux router this is easy, we can add variables to our paths and then pick and choose what articles we want to return based of these variables.&lt;/p&gt;

&lt;p&gt;Create a new route in your handleRequest function: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;myRouter.HandleFunc(&amp;quot;/article/{key}&amp;quot;, returnOneArticle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then create the new returnOneArticle function above it like so: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func returnOneArticle(w http.ResponseWriter, r *http.Request){
    vars := mux.Vars(r)
    key := vars[&amp;quot;key&amp;quot;]
    
    fmt.Fprintf(w, &amp;quot;Key: &amp;quot; + key)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So to explain this, in our route we’ve created a key variable. We are then accessing this new key variable within our new function by creating a map called vars and then selecting the key value from this map. We are able to do this for however many variables we want to set in our path like so: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func returnOneArticle(w http.ResponseWriter, r *http.Request){
    vars := mux.Vars(r)
    key := vars[&amp;quot;key&amp;quot;]
    var1 := vars[&amp;quot;var1&amp;quot;]
    var2 := vars[&amp;quot;var2&amp;quot;]
    
    fmt.Println(&amp;quot;Var 1: &amp;quot; + var1)
    fmt.Println(&amp;quot;Var 2: &amp;quot; + var2)
    fmt.Fprintf(w, &amp;quot;Key: &amp;quot; + key)
}

func handleRequests() {
    
    myRouter := mux.NewRouter().StrictSlash(true)
    myRouter.HandleFunc(&amp;quot;/&amp;quot;, homePage)
    myRouter.HandleFunc(&amp;quot;/all&amp;quot;, returnAllArticles)
    myRouter.HandleFunc(&amp;quot;/article/{key}/{var1}/{var2}/&amp;quot;, returnOneArticle)
    log.Fatal(http.ListenAndServe(&amp;quot;:10000&amp;quot;, myRouter))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you run this and hit: http://localhost:10000/article/1/1/2/ you should see your 2 variables printing out in the console and the page should also return Key: 1.&lt;/p&gt;

&lt;h2 id=&#34;real-life-examples&#34;&gt;Real Life Examples&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;If you want a real life RESTful json api to have a look at, why not take a look at the rest api powering this site&amp;rsquo;s backend: &lt;a href=&#34;https://github.com/elliotforbes/tutorialedge-rest-api&#34;&gt;Tutorialedge-Rest-API&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Sending Email Using Go And Mailgun</title>
      <link>/post/golang/sending-email-using-go-and-mailgun/</link>
      <pubDate>Sat, 15 Apr 2017 08:44:00 +0100</pubDate>
      
      <guid>/post/golang/sending-email-using-go-and-mailgun/</guid>
      <description>&lt;p&gt;In this tutorial I&#39;m going to be demonstrating how you can send mail with Go(Lang) and the mailgun api. Thankfully, mailgun&#39;s API is fantastic and sending mail is incredibly easy once you&#39;ve set everything up properly.&lt;/p&gt;

&lt;h2&gt;Requirements&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;You&#39;ll need a mailgun account with your own verified domains&lt;/li&gt;
&lt;li&gt;Mailgun&#39;s Go Package: Downloadable from here &gt; &lt;a href=&#34;https://github.com/mailgun/mailgun-go&#34; target=&#34;_blank&#34; &gt;https://github.com/mailgun/mailgun-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Your Mailgun&#39;s Public API Key&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Implementation&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;github.com/mailgun/mailgun-go&amp;quot;
)

func SendSimpleMessage(domain, apiKey string) (string, error) {
  mg := mailgun.NewMailgun(&amp;quot;tutorialedge.net&amp;quot;, apiKey, &amp;quot;key-12345671234567&amp;quot;)
  m := mg.NewMessage(
    &amp;quot;Excited User &amp;lt;elliot@tutorialedge.net&amp;gt;&amp;quot;,
    &amp;quot;Hello&amp;quot;,
    &amp;quot;Testing some Mailgun!&amp;quot;,
    &amp;quot;elliot@tutorialedge.net&amp;quot;,
  )
  _, id, err := mg.Send(m)
  return id, err
}

func main(){
    SendSimpleMessage(&amp;quot;postmaster@elliotforbes.co.uk&amp;quot;, &amp;quot;key-12345671234567&amp;quot;)
        
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Implementing the Bubble Sort Algorithm using Golang</title>
      <link>/post/golang/implementing-bubble-sort-with-golang/</link>
      <pubDate>Sat, 15 Apr 2017 08:34:43 +0100</pubDate>
      
      <guid>/post/golang/implementing-bubble-sort-with-golang/</guid>
      <description>

&lt;h2 id=&#34;what-is-bubble-sort&#34;&gt;What Is Bubble Sort?&lt;/h2&gt;

&lt;p&gt;Bubble sort is a sorting algorithm that sequentially goes through an array n times. Each time the algorithm runs through our array, it looks at the first element and then the second element, if the first element is larger than the second element then it swaps them, it then proceeds through the entire list performing this action.&lt;/p&gt;

&lt;h2 id=&#34;time-complexity&#34;&gt;Time Complexity&lt;/h2&gt;

&lt;p&gt;The time complexity for this algorithm is O(n^2) where n is the number of items being sorted. An example of a worst case scenario would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[9,8,7,6,5,4,3,2,1,0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case the entire array is backwards and as a result the bubble sorting algorithm would take 10 complete iterations through the array in order to sort this array.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Best Case Scenario&lt;/em&gt; - In the best case scenario the time complexity is O(n) where n is the number of items being sorted.&lt;/p&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;Go provides a very cool swapping mechanism using tuple assignment. We&amp;rsquo;ll create a swapped boolean flag which will indicate whether our list is fully sorted. We&amp;rsquo;ll then iterate through our list 10 times and check to see if the nth element is larger than the n+1th element. If it is we&amp;rsquo;ll swap it using tuple assignment.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
)

var toBeSorted [10]int = [10]int{1,3,2,4,8,6,7,2,3,0}

func bubbleSort(input [10]int) {
    // n is the number of items in our list
    n := 10
    swapped := true
    for swapped {
        swapped = false
        for i := 1; i &amp;lt; n-1; i++ {
            if input[i-1] &amp;gt; input[i] {
                fmt.Println(&amp;quot;Swapping&amp;quot;)
                // swap values using Go&#39;s tuple assignment
                input[i], input[i-1] = input[i-1], input[i]
                swapped = true
            }
        }
    }
    fmt.Println(input)
}


func main() {
    fmt.Println(&amp;quot;Hello World&amp;quot;)
    bubbleSort(toBeSorted)
    
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Writing A Twitter Bot in Golang</title>
      <link>/post/golang/writing-a-twitter-bot-golang/</link>
      <pubDate>Sun, 09 Apr 2017 21:33:19 +0100</pubDate>
      
      <guid>/post/golang/writing-a-twitter-bot-golang/</guid>
      <description>&lt;p&gt;In this tutorial I’m going to be demonstrating how to build a twitter bot using &lt;a href=&#34;https://github.com/dghubble/go-twitter&#34;&gt;go-twitter&lt;/a&gt;, a popular Go client library for the Twitter API.&lt;/p&gt;

&lt;p&gt;I’ll be demonstrating how you can build a go based twitter bot that will be able to do such things as automatically reply to tweets and favourite tweets that contain a specific hashtag.&lt;/p&gt;

&lt;h2&gt;Connecting to Twitter&lt;/h2&gt;

&lt;p&gt;Just like with the &lt;a href=&#34;https://tutorialedge.net/creating-python-twitter-bot-using-twitter-api&#34;&gt;Python version of this tutorial&lt;/a&gt;, you’ll have to create an app in twitter’s &lt;a href=”https://apps.twitter.com/”&gt;app control panel&lt;/a&gt;. Once you’ve created a new application, it should present you with all the secret tokens and keys that you need in order to proceed.&lt;/p&gt;

&lt;h2&gt;Writing our Basic Go Twitter Bot&lt;/h2&gt;

&lt;p&gt;Once you’ve got all the access tokens and secret tokens ready, it’s time to start implementing our Bot. Create a new file called &lt;b&gt;twitter-bot.go&lt;/b&gt; and add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;os/signal&amp;quot;
    &amp;quot;syscall&amp;quot;
    
    &amp;quot;github.com/dghubble/go-twitter/twitter&amp;quot;
    &amp;quot;github.com/dghubble/oauth1&amp;quot;
)

func configure() {
    // Pass in your consumer key (API Key) and your Consumer Secret (API Secret) 
    config := oauth1.NewConfig(&amp;quot;consumer-key&amp;quot;, &amp;quot;consumer-secret&amp;quot;)
    // Pass in your Access Token and your Access Token Secret
    token := oauth1.NewToken(&amp;quot;access-token&amp;quot;, &amp;quot;access-token-secret&amp;quot;)
    httpClient := config.Client(oauth1.NoContext, token)
    client := twitter.NewClient(httpClient)
    
    
    demux := twitter.NewSwitchDemux()
    
    demux.Tweet = func(tweet *twitter.Tweet){
        fmt.Println(tweet.Text)
    }
    
    demux.DM = func(dm *twitter.DirectMessage){
        fmt.Println(dm.SenderID)
    }
    
    fmt.Println(&amp;quot;Starting Stream...&amp;quot;)
    
    // FILTER
	filterParams := &amp;amp;twitter.StreamFilterParams{
		Track:         []string{&amp;quot;cat&amp;quot;},
		StallWarnings: twitter.Bool(true),
	}
	stream, err := client.Streams.Filter(filterParams)
	if err != nil {
		log.Fatal(err)
	}
    
    // Receive messages until stopped or stream quits
	go demux.HandleChan(stream.Messages)

	// Wait for SIGINT and SIGTERM (HIT CTRL-C)
	ch := make(chan os.Signal)
	signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
	log.Println(&amp;lt;-ch)

	fmt.Println(&amp;quot;Stopping Stream...&amp;quot;)
	stream.Stop()
    
}

func main() {
    fmt.Println(&amp;quot;Go-Twitter Bot v0.01&amp;quot;)
    configure()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang MySQL Tutorial</title>
      <link>/post/golang/golang-mysql-tutorial/</link>
      <pubDate>Sun, 09 Apr 2017 21:28:15 +0100</pubDate>
      
      <guid>/post/golang/golang-mysql-tutorial/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;In this tutorial I’ll be demonstrating how you can connect to a MySQL database and perform basic SQL statements using Go.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In order to do this we’ll be using &lt;a href=”https://github.com/go-sql-driver/mysql”&gt;&lt;a href=&#34;https://github.com/go-sql-driver/mysql&#34;&gt;https://github.com/go-sql-driver/mysql&lt;/a&gt;&lt;/a&gt; as our MySQL driver. Go-SQL-Driver is a lightweight and fast MySQL driver that supports connections over TCP/IPv4, TCP/IPv6, Unix domain sockets or custom protocols and features automatic handling of broken connections.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Github Repo: &lt;strong&gt;&lt;a href=&#34;https://github.com/go-sql-driver/mysql&#34;&gt;go-sql-driver/mysql&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;We’ll begin by connecting to a database we’ve set up on our local machine and then go on to perform some basic insert and select statements.&lt;/p&gt;

&lt;h4 id=&#34;connecting-to-a-mysql-database&#34;&gt;Connecting to a MySQL database&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;database/sql&amp;quot;
    _ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)

func main() {
    fmt.Println(&amp;quot;Go MySQL Tutorial&amp;quot;)
    
    // Open up our database connection.
    // I&#39;ve set up a database on my local machine using phpmyadmin.
    // The database is called testDb
    db, err := sql.Open(&amp;quot;mysql&amp;quot;, &amp;quot;username:password@tcp(127.0.0.1:3306)/test&amp;quot;)
    
    // if there is an error opening the connection, handle it
    if err != nil {
        panic(err.Error())
    }
    
    // defer the close till after the main function has finished
    // executing 
    defer db.Close()
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Performing Basic SQL Commands&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;db.Query(sql)&lt;/code&gt; allows us to perform any SQL command we so desire. Simply construct the string and pass it in as a parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;database/sql&amp;quot;
    _ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)

func main() {
    fmt.Println(&amp;quot;Go MySQL Tutorial&amp;quot;)
    
    // Open up our database connection.
    // I&#39;ve set up a database on my local machine using phpmyadmin.
    // The database is called testDb
    db, err := sql.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:password1@tcp(127.0.0.1:3306)/test&amp;quot;)
    
    // if there is an error opening the connection, handle it
    if err != nil {
        panic(err.Error())
    }
    
    // defer the close till after the main function has finished
    // executing 
    defer db.Close()
    
    // perform a db.Query insert 
    insert, err := db.Query(&amp;quot;INSERT INTO test VALUES ( 2, &#39;TEST&#39; )&amp;quot;)
    
    // if there is an error inserting, handle it
    if err != nil {
        panic(err.Error())
    }
    // be careful deferring Queries if you are using transactions
    defer insert.Close()
    
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;populating-structs-from-results&#34;&gt;Populating Structs from Results&lt;/h2&gt;

&lt;p&gt;Retrieving a set of results from the database is all well and good, but we need to be able to read these results or populating existing &lt;code&gt;structs&lt;/code&gt; so that we can parse them and modify them easily. In order to parse a number of rows we can use the &lt;code&gt;.Scan(args...)&lt;/code&gt; method which takes in any number of arguments and allows us to populate a composite object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * Tag... - a very simple struct
 */
type Tag struct {
	ID   int    `json:&amp;quot;id&amp;quot;`
	Name string `json:&amp;quot;name&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	// Open up our database connection.
	db, err := sql.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:pass1@tcp(127.0.0.1:3306)/tuts&amp;quot;)

	// if there is an error opening the connection, handle it
	if err != nil {
		log.Print(err.Error())
	}
	defer db.Close()

	// Execute the query
	results, err := db.Query(&amp;quot;SELECT id, name FROM tags&amp;quot;)
	if err != nil {
		panic(err.Error()) // proper error handling instead of panic in your app
	}

	for results.Next() {
		var tag Tag
		// for each row, scan the result into our tag composite object
		err = results.Scan(&amp;amp;tag.ID, &amp;amp;tag.Name)
		if err != nil {
			panic(err.Error()) // proper error handling instead of panic in your app
		}
                // and then print out the tag&#39;s Name attribute
		log.Printf(tag.Name)
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example we retrieved 2 columns from the tags database and then used .Scan to populate our tag object.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that if you retrieve 3 fields from the database and Scan only has 2 parameters, it will fail. They need to match up exactly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;querying-a-single-row&#34;&gt;Querying a Single Row&lt;/h2&gt;

&lt;p&gt;Say we wanted to query a single row this time and had an ID and again wanted to populate our struct. We could do that like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var tag Tag
// Execute the query
err = db.QueryRow(&amp;quot;SELECT id, name FROM tags where id = ?&amp;quot;, 2).Scan(&amp;amp;tag.ID, &amp;amp;tag.Name)
if err != nil {
	panic(err.Error()) // proper error handling instead of panic in your app
}

log.Println(tag.ID)
log.Println(tag.Name)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you found this tutorial helpful or require more assistance then please don&amp;rsquo;t hesitate to let me know in the comments section below:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Recommended Reading: &lt;a href=&#34;https://tutorialedge.net/creating-simple-restful-json-api-with-go&#34;&gt;Creating a RESTful JSON api with Go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Golang Integer String Conversion Tutorial</title>
      <link>/post/golang/golang-integer-string-conversion-tutorial/</link>
      <pubDate>Sun, 09 Apr 2017 21:09:39 +0100</pubDate>
      
      <guid>/post/golang/golang-integer-string-conversion-tutorial/</guid>
      <description>

&lt;p&gt;In this tutorial we briefly look at how one can convert an integer to string and back again in GoLang. In order to do this we’ll be using the ‘strconv’ package and the Atoi and Itoa functions.&lt;/p&gt;

&lt;p&gt;Full documentation of the strconv package can be found here: &lt;a href=&#34;https://golang.org/pkg/strconv/&#34;&gt;Strconv Package&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;string-to-integer-conversion&#34;&gt;String to Integer Conversion&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;func strToIntConversion() {
	fmt.Println(&amp;quot;String to Integer Value Conversion&amp;quot;)

	var ourInteger int
	// use the strconv package to convert our string &#39;12345&#39; to an integer value
	ourInteger, err := strconv.Atoi(&amp;quot;12345&amp;quot;)

	// if there has been an error then handle it here
	if err != nil {
		fmt.Println(err)
	}

	// this should print out 12346
	fmt.Println(ourInteger + 1)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;integer-to-string-conversion&#34;&gt;Integer to String Conversion&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;func intToStringConversion() {
	fmt.Println(&amp;quot;integer to string conversion&amp;quot;)

	var ourString string

	ourString = strconv.Itoa(12345)

	// print out our string value
	fmt.Println(ourString)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Full Source Code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;strconv&amp;quot;
)

func strToIntConversion() {
	fmt.Println(&amp;quot;String to Integer Value Conversion&amp;quot;)

	var ourInteger int
	// use the strconv package to convert our string &#39;12345&#39; to an integer value
	ourInteger, err := strconv.Atoi(&amp;quot;12345&amp;quot;)

	// if there has been an error then handle it here
	if err != nil {
		fmt.Println(err)
	}

	// this should print out 12346
	fmt.Println(ourInteger + 1)
}


func intToStringConversion() {
	fmt.Println(&amp;quot;integer to string conversion&amp;quot;)

	var ourString string

	ourString = strconv.Itoa(12345)

	// print out our string value
	fmt.Println(ourString)

}


func main() {
	strToIntConversion()
	intToStringConversion()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Parsing XML Files With Golang</title>
      <link>/post/golang/parsing-xml-with-golang/</link>
      <pubDate>Sun, 09 Apr 2017 21:07:45 +0100</pubDate>
      
      <guid>/post/golang/parsing-xml-with-golang/</guid>
      <description>

&lt;p&gt;In this tutorial we look at how you can effectively read in an XML file from the file system and then parse this file using Go’s &lt;a href=&#34;https://golang.org/pkg/encoding/xml/&#34;&gt;“encoding/xml” Package&lt;/a&gt;. We’ll look at how you can traverse multiple nested xml elements and then we’ll simply print this out to our terminal window.&lt;/p&gt;

&lt;h2 id=&#34;our-example-xml-file&#34;&gt;Our Example XML File&lt;/h2&gt;

&lt;p&gt;So to begin with, we’ll need an xml file that we can traverse.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;users&amp;gt;
  &amp;lt;user type=&amp;quot;admin&amp;quot;&amp;gt;
    &amp;lt;name&amp;gt;Elliot&amp;lt;/name&amp;gt;
    &amp;lt;social&amp;gt;
      &amp;lt;facebook&amp;gt;https://facebook.com&amp;lt;/facebook&amp;gt;
      &amp;lt;twitter&amp;gt;https://twitter.com&amp;lt;/twitter&amp;gt;
      &amp;lt;youtube&amp;gt;https://youtube.com&amp;lt;/youtube&amp;gt;
    &amp;lt;/social&amp;gt;
  &amp;lt;/user&amp;gt;  
  &amp;lt;user type=&amp;quot;reader&amp;quot;&amp;gt;
    &amp;lt;name&amp;gt;Fraser&amp;lt;/name&amp;gt;
    &amp;lt;social&amp;gt;
      &amp;lt;facebook&amp;gt;https://facebook.com&amp;lt;/facebook&amp;gt;
      &amp;lt;twitter&amp;gt;https://twitter.com&amp;lt;/twitter&amp;gt;
      &amp;lt;youtube&amp;gt;https://youtube.com&amp;lt;/youtube&amp;gt;
    &amp;lt;/social&amp;gt;
  &amp;lt;/user&amp;gt;  
&amp;lt;/users&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You’ll see the above xml has attributes set on the user tags, nested elements and if you are able to parse this then you should, by extension, be able to parse any xml file regardless of size.&lt;/p&gt;

&lt;h2 id=&#34;reading-in-our-file&#34;&gt;Reading in our File&lt;/h2&gt;

&lt;p&gt;The first obstacle we’ll have to overcome is reading this file into memory. We can do this by using a combination of the “os” package and the “io/ioutil” package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main


import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;os&amp;quot;
)


func main() {


	// Open our xmlFile
	xmlFile, err := os.Open(&amp;quot;users.xml&amp;quot;)
	// if we os.Open returns an error then handle it
	if err != nil {
		fmt.Println(err)
	}


	fmt.Println(&amp;quot;Successfully Opened users.xml&amp;quot;)
	// defer the closing of our xmlFile so that we can parse it later on
	defer xmlFile.Close()


}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;defining-our-structs&#34;&gt;Defining our Structs&lt;/h2&gt;

&lt;p&gt;Before we can parse our xml file, we need to define some structs. We’ll have one to represent the complete list of users, one to represent our user and then one to represent our users social links.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import (
  ... 
  // remember to add encoding/xml to your list of imports
	&amp;quot;encoding/xml&amp;quot;
	...
)


// our struct which contains the complete
// array of all Users in the file
type Users struct {
	XMLName xml.Name `xml:&amp;quot;users&amp;quot;`
	Users   []User   `xml:&amp;quot;user&amp;quot;`
}


// the user struct, this contains our
// Type attribute, our user&#39;s name and
// a social struct which will contain all
// our social links
type User struct {
	XMLName xml.Name `xml:&amp;quot;user&amp;quot;`
	Type    string   `xml:&amp;quot;type,attr&amp;quot;`
	Name    string   `xml:&amp;quot;name&amp;quot;`
	Social  Social   `xml:&amp;quot;social&amp;quot;`
}


// a simple struct which contains all our
// social links
type Social struct {
	XMLName  xml.Name `xml:&amp;quot;social&amp;quot;`
	Facebook string   `xml:&amp;quot;facebook&amp;quot;`
	Twitter  string   `xml:&amp;quot;twitter&amp;quot;`
	Youtube  string   `xml:&amp;quot;youtube&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unmarshalling-our-xml&#34;&gt;Unmarshalling Our XML&lt;/h2&gt;

&lt;p&gt;So above we’ve seen how to load in our file into memory, in order to marshal it we need to convert this file to a byte array and then use the xml.Unmarshal method in order to populate our Users array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// read our opened xmlFile as a byte array.
	byteValue, _ := ioutil.ReadAll(xmlFile)


	// we initialize our Users array
	var users Users
	// we unmarshal our byteArray which contains our
	// xmlFiles content into &#39;users&#39; which we defined above
	xml.Unmarshal(byteValue, &amp;amp;users)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;full-implementation&#34;&gt;Full Implementation&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;package main


import (
	&amp;quot;encoding/xml&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;os&amp;quot;
)


// our struct which contains the complete
// array of all Users in the file
type Users struct {
	XMLName xml.Name `xml:&amp;quot;users&amp;quot;`
	Users   []User   `xml:&amp;quot;user&amp;quot;`
}


// the user struct, this contains our
// Type attribute, our user&#39;s name and
// a social struct which will contain all
// our social links
type User struct {
	XMLName xml.Name `xml:&amp;quot;user&amp;quot;`
	Type    string   `xml:&amp;quot;type,attr&amp;quot;`
	Name    string   `xml:&amp;quot;name&amp;quot;`
	Social  Social   `xml:&amp;quot;social&amp;quot;`
}


// a simple struct which contains all our
// social links
type Social struct {
	XMLName  xml.Name `xml:&amp;quot;social&amp;quot;`
	Facebook string   `xml:&amp;quot;facebook&amp;quot;`
	Twitter  string   `xml:&amp;quot;twitter&amp;quot;`
	Youtube  string   `xml:&amp;quot;youtube&amp;quot;`
}


func main() {


	// Open our xmlFile
	xmlFile, err := os.Open(&amp;quot;users.xml&amp;quot;)
	// if we os.Open returns an error then handle it
	if err != nil {
		fmt.Println(err)
	}


	fmt.Println(&amp;quot;Successfully Opened users.xml&amp;quot;)
	// defer the closing of our xmlFile so that we can parse it later on
	defer xmlFile.Close()


	// read our opened xmlFile as a byte array.
	byteValue, _ := ioutil.ReadAll(xmlFile)


	// we initialize our Users array
	var users Users
	// we unmarshal our byteArray which contains our
	// xmlFiles content into &#39;users&#39; which we defined above
	xml.Unmarshal(byteValue, &amp;amp;users)


	// we iterate through every user within our users array and
	// print out the user Type, their name, and their facebook url
	// as just an example
	for i := 0; i &amp;lt; len(users.Users); i++ {
		fmt.Println(&amp;quot;User Type: &amp;quot; + users.Users[i].Type)
		fmt.Println(&amp;quot;User Name: &amp;quot; + users.Users[i].Name)
		fmt.Println(&amp;quot;Facebook Url: &amp;quot; + users.Users[i].Social.Facebook)
	}


}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope you found this tutorial beneficial, if you’ve got anything you wish to add then please do in the comments section below!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Parsing JSON files With Golang</title>
      <link>/post/golang/parsing-json-with-golang/</link>
      <pubDate>Sun, 09 Apr 2017 21:07:11 +0100</pubDate>
      
      <guid>/post/golang/parsing-json-with-golang/</guid>
      <description>

&lt;p&gt;JSON or Javascript Object Notation as it is short for, is a standard format for sending and receiving information. We could represent the same information with either XML or JSON, but JSON provides one advantage in the fact it is far more compact. This provides advantageous for situations where bandwidth is
In this tutorial we’ll be looking at how one can parse xml files from the local file system using Golang’s in-built ‘encoding/json’ package.&lt;/p&gt;

&lt;p&gt;JSON is now the most popular message format available and you&amp;rsquo;ll find that most RESTful APIs provide JSON responses due to the fact it&amp;rsquo;s easily readable and most popular languages provide JSON support by default.&lt;/p&gt;

&lt;h2 id=&#34;the-encoding-json-package&#34;&gt;The Encoding/Json Package&lt;/h2&gt;

&lt;p&gt;I recommend you check out the official documentation for:  &lt;a href=&#34;https://golang.org/pkg/encoding/json/&#34;&gt;Encoding/Json&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;our-sample-json-file&#34;&gt;Our Sample JSON File&lt;/h2&gt;

&lt;p&gt;For the purpose of this tutorial we’ll be parsing the following json file. We&amp;rsquo;ll be parsing nested elements, integers and arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;users&amp;quot;: [
    {
      &amp;quot;name&amp;quot; : &amp;quot;Elliot&amp;quot;,
      &amp;quot;type&amp;quot; : &amp;quot;Reader&amp;quot;,
      &amp;quot;age&amp;quot; : 23,
      &amp;quot;social&amp;quot; : {
        &amp;quot;facebook&amp;quot; : &amp;quot;https://facebook.com&amp;quot;,
        &amp;quot;twitter&amp;quot; : &amp;quot;https://twitter.com&amp;quot;
      }
    },
    {
      &amp;quot;name&amp;quot; : &amp;quot;Fraser&amp;quot;,
      &amp;quot;type&amp;quot; : &amp;quot;Author&amp;quot;,
      &amp;quot;age&amp;quot; : 17,
      &amp;quot;social&amp;quot; : {
        &amp;quot;facebook&amp;quot; : &amp;quot;https://facebook.com&amp;quot;,
        &amp;quot;twitter&amp;quot; : &amp;quot;https://twitter.com&amp;quot;
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reading-the-json-file&#34;&gt;Reading the JSON File&lt;/h2&gt;

&lt;p&gt;We’ll be using the os package in order to open up our users.xml file from our filesystem.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Open our xmlFile
xmlFile, err := os.Open(&amp;quot;users.xml&amp;quot;)
// if we os.Open returns an error then handle it
if err != nil {
	fmt.Println(err)
}
fmt.Println(&amp;quot;Successfully Opened users.xml&amp;quot;)
// defer the closing of our xmlFile so that we can parse it later on
defer xmlFile.Close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;defining-our-structs&#34;&gt;Defining our Structs&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll be decoding JSON and populating these Go data structures by unmarshalling but first we&amp;rsquo;ll need to define these data structures like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Import (
	…
	// import our encoding/json package
	“encoding/json”
	…
)


// Users struct which contains
// an array of users
type Users struct {
	Users []User `json:&amp;quot;users&amp;quot;`
}


// User struct which contains a name
// a type and a list of social links
type User struct {
	Name   string `json:&amp;quot;name&amp;quot;`
	Type   string `json:&amp;quot;type&amp;quot;`
	Age    int    `json:&amp;quot;Age&amp;quot;`
	Social Social `json:&amp;quot;social&amp;quot;`
}


// Social struct which contains a
// list of links
type Social struct {
	Facebook string `json:&amp;quot;facebook&amp;quot;`
	Twitter  string `json:&amp;quot;twitter&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unmarshalling-our-json&#34;&gt;Unmarshalling our JSON&lt;/h2&gt;

&lt;p&gt;Once we&amp;rsquo;ve used the os.Open function to read our file into memory, we then have to convert it toa byte array using ioutil.ReadAll. Once it&amp;rsquo;s in a byte array we can pass it to our json.Unmarshal() method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// read our opened xmlFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)


	// we initialize our Users array
	var users Users


	// we unmarshal our byteArray which contains our
	// jsonFile&#39;s content into &#39;users&#39; which we defined above
	json.Unmarshal(byteValue, &amp;amp;users)


	// we iterate through every user within our users array and
	// print out the user Type, their name, and their facebook url
	// as just an example
	for i := 0; i &amp;lt; len(users.Users); i++ {
		fmt.Println(&amp;quot;User Type: &amp;quot; + users.Users[i].Type)
		fmt.Println(&amp;quot;User Age: &amp;quot; + strconv.Itoa(users.Users[i].Age))
		fmt.Println(&amp;quot;User Name: &amp;quot; + users.Users[i].Name)
		fmt.Println(&amp;quot;Facebook Url: &amp;quot; + users.Users[i].Social.Facebook)
	}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;full-implementation&#34;&gt;Full Implementation&lt;/h2&gt;

&lt;p&gt;Below you&amp;rsquo;ll find the full implementation of this tutorial.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main


import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
)


// Users struct which contains
// an array of users
type Users struct {
	Users []User `json:&amp;quot;users&amp;quot;`
}


// User struct which contains a name
// a type and a list of social links
type User struct {
	Name   string `json:&amp;quot;name&amp;quot;`
	Type   string `json:&amp;quot;type&amp;quot;`
	Age    int    `json:&amp;quot;Age&amp;quot;`
	Social Social `json:&amp;quot;social&amp;quot;`
}


// Social struct which contains a
// list of links
type Social struct {
	Facebook string `json:&amp;quot;facebook&amp;quot;`
	Twitter  string `json:&amp;quot;twitter&amp;quot;`
}


func main() {


	// Open our jsonFile
	jsonFile, err := os.Open(&amp;quot;users.json&amp;quot;)
	// if we os.Open returns an error then handle it
	if err != nil {
		fmt.Println(err)
	}


	fmt.Println(&amp;quot;Successfully Opened users.json&amp;quot;)
	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()


	// read our opened xmlFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)


	// we initialize our Users array
	var users Users


	// we unmarshal our byteArray which contains our
	// jsonFile&#39;s content into &#39;users&#39; which we defined above
	json.Unmarshal(byteValue, &amp;amp;users)


	// we iterate through every user within our users array and
	// print out the user Type, their name, and their facebook url
	// as just an example
	for i := 0; i &amp;lt; len(users.Users); i++ {
		fmt.Println(&amp;quot;User Type: &amp;quot; + users.Users[i].Type)
		fmt.Println(&amp;quot;User Age: &amp;quot; + strconv.Itoa(users.Users[i].Age))
		fmt.Println(&amp;quot;User Name: &amp;quot; + users.Users[i].Name)
		fmt.Println(&amp;quot;Facebook Url: &amp;quot; + users.Users[i].Social.Facebook)
	}


}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you found this tutorial helpful or have anything else to add then please let me know in the comments section below.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrency With Golang Goroutines</title>
      <link>/post/golang/concurrency-with-golang-goroutines/</link>
      <pubDate>Sun, 09 Apr 2017 21:06:27 +0100</pubDate>
      
      <guid>/post/golang/concurrency-with-golang-goroutines/</guid>
      <description>

&lt;p&gt;Go is an incredibly performant language that features a hell of a lot of great features that allow you to build incredibly fast applications. It redefines what it means to build concurrent programs by offering what are called goroutines and channels. Using goroutines is a very easy way to turn what would be a sequential program into a concurrent program without having to worry about things like creating threads or thread-pools.&lt;/p&gt;

&lt;h2 id=&#34;what-are-goroutines&#34;&gt;What Are Goroutines?&lt;/h2&gt;

&lt;p&gt;So to begin with, what are Goroutines? Goroutines are incredibly lightweight “threads” managed by the go runtime. They enable us to create asynchronous parallel programs that can execute some tasks far quicker than if they were written in a sequential manner.&lt;/p&gt;

&lt;div class=&#34;note&#34;&gt;
Goroutines are far smaller that threads, they typically take around 2kB of stack space to initialize compared to a thread which takes 1Mb.
&lt;/div&gt;

&lt;p&gt;Goroutines are typically multiplexed onto a very small number of OS threads which typically mean concurrent go programs require far less resources in order to provide the same level of performance as languages such as Java. Creating a thousand goroutines would typically require one or two OS threads at most, whereas if we were to do the same thing in java it would require 1,000 full threads each taking a minimum of 1Mb of Heap space.&lt;/p&gt;

&lt;p&gt;By mapping hundreds or thousands of goroutines onto a single thread we don’t have to worry about the performance hit when creating and destroying threads in our application. It’s incredibly in-expensive to create and destroy new goroutines due to their size and the efficient way that go handles them.&lt;/p&gt;

&lt;h2 id=&#34;a-simple-sequential-program&#34;&gt;A Simple Sequential Program&lt;/h2&gt;

&lt;p&gt;As a means of demonstration, we’ll create a function that takes in an int value and prints a number to the console &lt;strong&gt;n&lt;/strong&gt; times. We’ll also add a sleep function which will wait for a second before printing the second number:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main


import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)


// a very simple function that we&#39;ll
// make asynchronous later on
func compute(value int) {
	for i := 0; i &amp;lt; value; i++ {
		time.Sleep(time.Second)
		fmt.Println(i)
	}
}


func main() {
	fmt.Println(&amp;quot;Goroutine Tutorial&amp;quot;)


  // sequential execution of our compute function 
	compute(10)
	compute(10)


  // we scan fmt for input and print that to our console
	var input string
	fmt.Scanln(&amp;amp;input)


}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you execute the code above you should see that it prints 0 to 9 twice in a row. Total execution time for this sequential program is just over 20 seconds.&lt;/p&gt;

&lt;h2 id=&#34;making-our-program-asynchronous&#34;&gt;Making our Program Asynchronous&lt;/h2&gt;

&lt;p&gt;If we aren’t fussed about the order in which our program prints out the values 0 to &lt;strong&gt;n&lt;/strong&gt; then we can speed this program up by using goroutines and making it asynchronous.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main


import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)


// notice we&#39;ve not changed anything in this function 
// when compared to our previous sequential program
func compute(value int) {
	for i := 0; i &amp;lt; value; i++ {
		time.Sleep(time.Second)
		fmt.Println(i)
	}
}


func main() {
	fmt.Println(&amp;quot;Goroutine Tutorial&amp;quot;)


  // notice how we&#39;ve added the &#39;go&#39; keyword 
  // in front of both our compute function calls
	go compute(10)
	go compute(10)
  
	var input string
	fmt.Scanln(&amp;amp;input)


}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only thing we needed to change to our existing sequential go program was to add the ‘go’ keyword in front of our compute function invocation. Here we’ve essentially created two separate goroutines that should now execute in parallel.&lt;/p&gt;

&lt;p&gt;Try executing this in your browser and you should see 0,0,1,1,2,2… and so on up till ..9,9 print out in our console. And if you time this program’s execution then we are suddenly down to roughly 10 seconds.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>