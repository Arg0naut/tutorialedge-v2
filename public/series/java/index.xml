<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on TutorialEdge.net</title>
    <link>https://tutorialedge.net/series/java/index.xml</link>
    <description>Recent content in Java on TutorialEdge.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://tutorialedge.net/series/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java Multithreading Tutorial Using Callable</title>
      <link>https://tutorialedge.net/post/java/java-multithreading-tutorial-using-callable/</link>
      <pubDate>Sat, 15 Apr 2017 08:42:15 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/java/java-multithreading-tutorial-using-callable/</guid>
      <description>&lt;p&gt;In this tutorial I’ll be giving you a brief introduction to the world of concurrent programming using the Java programming language. By the end of this tutorial you should hopefully have a feel for what it takes to write simple, multi-threaded java programs and an understanding of how these can help improve the performance of your programs on multithreaded/multicore machines.&lt;/p&gt;

&lt;h2&gt;Requirements&lt;/h2&gt;

&lt;p&gt;In order to successfully complete this tutorial you will need to have Java 7 installed and running on your machine, as well as a method for editing and executing your Java code for which I would recommend the Eclipse or Intellij IDE.&lt;/p&gt;

&lt;p&gt;You’ll also need a basic understanding of the Java programming language. Everything covered here will be built on top of a pre-existing Java background.&lt;/p&gt;

&lt;h2&gt;Introduction - What is Concurrent Programming?&lt;/h2&gt;

&lt;p&gt;“Concurrent computing is a form of computing in which several computations are executing during overlapping time periods - concurrently - instead of sequentially” - Wikipedia&lt;/p&gt;

&lt;p&gt;What this essentially means for us is that we can have our programs utilizing more of the power that is contained within our CPUs by spreading the load evenly across multiple cores and threads. If you gave 1 worker 1,000,000 computations to work through and each computation took 1 minute, the fastest that worker could complete that task is in 1,000,000 minutes. If you had 100 workers working on that 1,000,000 computations then it should take roughly 100 times faster, this isn’t always the case with computers but we do see tremendous performance enhancements and far greater CPU utilization. &lt;/p&gt;

&lt;p&gt;One thing to bear in mind is that we don’t have an infinite number of threads on a CPU and creating more and more threads could eventually start to severely hamper your program’s performance.&lt;/p&gt;

&lt;h2&gt;Implementing this in Java&lt;/h2&gt;

&lt;p&gt;There are multiple ways we can implement multithreading into our programs but the one I’m going to be focusing on in this tutorial is the Callable method. This method is advantageous over the Runnable and Thread methods as it allows you to see the results of execution.&lt;/p&gt;

&lt;p&gt;We’ll start of with a basic Java class implementing Callable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.tutorialedge.net;

import java.util.concurrent.Callable;

public class Worker implements Callable{
	
	String identifier;
	
	Worker(String identifier){
		this.identifier = identifier;
	}
	
	@Override
	public String call() throws Exception {
		System.out.println(&amp;quot;Worker ID: &amp;quot; + this.identifier);
		
		for(int i = 0; i &amp;lt; 10000; i++){
			System.out.println(&amp;quot;ID: &amp;quot; + this.identifier + &amp;quot; ,Value: &amp;quot; + i);
		}
		
		return null;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next thing we’ll do is create a main method which will run our workers for us. This will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.tutorialedge.net;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {

	public static void main(String[] args){
		ExecutorService pool = Executors.newFixedThreadPool(4);
		
		Worker worker1 = new Worker(&amp;quot;1&amp;quot;);
		Worker worker2 = new Worker(&amp;quot;2&amp;quot;);
		Worker worker3 = new Worker(&amp;quot;3&amp;quot;);
		Worker worker4 = new Worker(&amp;quot;4&amp;quot;);
		
		pool.submit(worker1);
		pool.submit(worker2);
		pool.submit(worker3);
		pool.submit(worker4);
		
		pool.shutdown();
		
		System.out.println(&amp;quot;Hello World&amp;quot;);
	}
	
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UDP Client Server Tutorial Java</title>
      <link>https://tutorialedge.net/post/java/udp-client-server-tutorial-java/</link>
      <pubDate>Sun, 09 Apr 2017 21:24:02 +0100</pubDate>
      
      <guid>https://tutorialedge.net/post/java/udp-client-server-tutorial-java/</guid>
      <description>

&lt;p&gt;In this tutorial we’ll be looking at how we can set up a UDP client and server using Java’s DatagramSocket’s.&lt;/p&gt;

&lt;h2 id=&#34;udp-server&#34;&gt;UDP Server&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;package com.tutorialedge.server;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;

import org.apache.log4j.Logger;

import com.tutorialedge.driver.ServerDriver;

public class Server implements Runnable{
	final static Logger logger = Logger.getLogger(Server.class);
	
	private DatagramSocket serverSocket;
	
	private byte[] in;
	private byte[] out;
	
	/*
	 * Our constructor which instantiates our serverSocket
	 */
	public Server() throws SocketException{
		serverSocket = new DatagramSocket(10000);
	}

	public void run() {
		while(true){
			try {
				in = new byte[1024];
				out = new byte[1024];
				
				/*
				 * Create our inbound datagram packet
				 */
				DatagramPacket receivedPacket = new DatagramPacket(in, in.length);
				serverSocket.receive(receivedPacket);
				
				/*
				 * Get the data from the packet we&#39;ve just received
				 * and transform it to uppercase.
				 */
				String text = new String(receivedPacket.getData());
				out = text.toUpperCase().getBytes();
				logger.info(&amp;quot;String Received: &amp;quot; + text);
				
				/*
				 * Retrieve the IP Address and port number of the datagram packet
				 * we&#39;ve just received
				 */
				InetAddress IPAddress = receivedPacket.getAddress();
				int port = receivedPacket.getPort();
				
				/*
				 * Create a DatagramPacket which will return our message back to the last system
				 * that we received from
				 */
				DatagramPacket sendPacket = new DatagramPacket(in, in.length, IPAddress, port);
				serverSocket.send(sendPacket);
			} catch (IOException e) {
				/*
				 * Handle our servers exception
				 */
				logger.info(&amp;quot;Exception thrown: &amp;quot; + e.getLocalizedMessage());
			}
			
		}
	}
	
	
	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;udp-client&#34;&gt;UDP Client&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;package com.tutorialedge.client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;

import org.apache.log4j.Logger;

import com.tutorialedge.server.Server;

public class Client implements Runnable{
	final static Logger logger = Logger.getLogger(Server.class);
	
	private BufferedReader inFromUser;
	private DatagramSocket clientSocket;
	private InetAddress IPAddress;
	
	/*
	 * Our byte arrays that we&#39;ll use to read in and send out to our UDP server
	 */
	private byte[] outData;
    private byte[] inData;
	
    /*
     * Our Client constructor which instantiates our clientSocket
     * and get&#39;s our IPAddress
     */
	public Client() throws SocketException, UnknownHostException{
		clientSocket = new DatagramSocket();
		IPAddress = InetAddress.getByName(&amp;quot;localhost&amp;quot;);
		inFromUser = new BufferedReader(new InputStreamReader(System.in));
	}
	
	private void shutdown(){
		clientSocket.close();
	}
	
	public void run() {
		logger.info(&amp;quot;Client Started, Listening for Input:&amp;quot;);
		/*
		 * Start a while loop that will run until we kill the program, this will continuously
		 * poll for user input and send it to the server.
		 */
		while(true){
			try {
				inData = new byte[1024];
				outData = new byte[1024];
				/*
				 * First we read in the users input from the console.
				 */
				System.out.print(&amp;quot;&amp;gt; &amp;quot;);
				String sentence = inFromUser.readLine();
				outData = sentence.getBytes();
				
				/*
				 * Next we create a datagram packet which will allow us send our message back to our datagram server
				 */
				DatagramPacket out = new DatagramPacket(outData, outData.length, IPAddress, 10000);
				clientSocket.send(out);
				
				/*
				 * Once we&#39;ve sent our message we create a second datagram packet which will
				 * let us receive a response.
				 */
				DatagramPacket in = new DatagramPacket(inData, inData.length);
				clientSocket.receive(in);
				
				/*
				 * Finally we log the response from the server using log4j
				 */
				String modifiedSentence = new String(in.getData());
				logger.info(&amp;quot;Server &amp;gt;&amp;quot; + modifiedSentence);
				
			} catch (IOException e) {
				/*
				 * Here we need to capture any exceptions thrown by our application
				 */
				logger.error(&amp;quot;Exception Thrown: &amp;quot; + e.getLocalizedMessage());
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;serverdriver-class&#34;&gt;ServerDriver Class&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;package com.tutorialedge.driver;

import java.net.SocketException;

import org.apache.log4j.Logger;

import com.tutorialedge.server.Server;

public class ServerDriver {
	final static Logger logger = Logger.getLogger(ServerDriver.class);
	
	public static void main(String[] args) throws SocketException{
		logger.info(&amp;quot;Networking Tutorial v0.01&amp;quot;);
		new Thread(new Server()).start();
	}
	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;clientdriver-class&#34;&gt;ClientDriver Class&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;package com.tutorialedge.driver;

import java.net.SocketException;
import java.net.UnknownHostException;

import org.apache.log4j.Logger;

import com.tutorialedge.client.Client;

public class ClientDriver {
	final static Logger logger = Logger.getLogger(ServerDriver.class);
	
	public static void main(String[] args) throws SocketException, UnknownHostException{
		logger.info(&amp;quot;Starting Client...&amp;quot;);
		new Thread(new Client()).start();
	}
	
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>